// Package user provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package user_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	EpilotAuthScopes = "EpilotAuth.Scopes"
)

// Defines values for LoginParametersOauthResponseType.
const (
	Code  LoginParametersOauthResponseType = "code"
	Token LoginParametersOauthResponseType = "token"
)

// Defines values for OrganizationType.
const (
	OrganizationTypePartner OrganizationType = "Partner"
	OrganizationTypeVendor  OrganizationType = "Vendor"
)

// Defines values for OrganizationDetailType.
const (
	OrganizationDetailTypePartner OrganizationDetailType = "Partner"
	OrganizationDetailTypeVendor  OrganizationDetailType = "Vendor"
)

// Defines values for SignupUserPayloadLanguage.
const (
	SignupUserPayloadLanguageDe SignupUserPayloadLanguage = "de"
	SignupUserPayloadLanguageEn SignupUserPayloadLanguage = "en"
)

// Defines values for UserInvitationPayloadLanguage.
const (
	UserInvitationPayloadLanguageDe UserInvitationPayloadLanguage = "de"
	UserInvitationPayloadLanguageEn UserInvitationPayloadLanguage = "en"
)

// Defines values for UserV2Status.
const (
	Active      UserV2Status = "Active"
	Deactivated UserV2Status = "Deactivated"
	Deleted     UserV2Status = "Deleted"
	Pending     UserV2Status = "Pending"
)

// Defines values for ResendUserInvitationJSONBodyLanguage.
const (
	De ResendUserInvitationJSONBodyLanguage = "de"
	En ResendUserInvitationJSONBodyLanguage = "en"
)

// InviteToken defines model for InviteToken.
type InviteToken = string

// Limit defines model for Limit.
type Limit = float32

// LoginParameters defines model for LoginParameters.
type LoginParameters struct {
	CognitoIdentityPoolId   *string                           `json:"cognito_identity_pool_id,omitempty"`
	CognitoOauthDomain      *string                           `json:"cognito_oauth_domain,omitempty"`
	CognitoOauthScopes      *[]string                         `json:"cognito_oauth_scopes,omitempty"`
	CognitoRegion           *string                           `json:"cognito_region,omitempty"`
	CognitoUserPoolClientId *string                           `json:"cognito_user_pool_client_id,omitempty"`
	CognitoUserPoolId       *string                           `json:"cognito_user_pool_id,omitempty"`
	OauthResponseType       *LoginParametersOauthResponseType `json:"oauth_response_type,omitempty"`
	OrganizationId          *string                           `json:"organization_id,omitempty"`
	OrganizationName        *string                           `json:"organization_name,omitempty"`
	OrganizationType        *string                           `json:"organization_type,omitempty"`
}

// LoginParametersOauthResponseType defines model for LoginParameters.OauthResponseType.
type LoginParametersOauthResponseType string

// Offset defines model for Offset.
type Offset = float32

// Organization defines model for Organization.
type Organization struct {
	Address *struct {
		City         *string `json:"city"`
		Country      *string `json:"country"`
		PostalCode   *string `json:"postal_code"`
		Street       *string `json:"street"`
		StreetNumber *string `json:"street_number"`
	} `json:"address,omitempty"`
	Email            *string           `json:"email"`
	Id               *OrganizationId   `json:"id,omitempty"`
	IsUnlicensedOrg  *bool             `json:"is_unlicensed_org"`
	LogoThumbnailUrl *string           `json:"logo_thumbnail_url"`
	LogoUrl          *string           `json:"logo_url"`
	Name             *string           `json:"name"`
	Phone            *string           `json:"phone"`
	PricingTier      *string           `json:"pricing_tier"`
	Signature        *string           `json:"signature"`
	Symbol           *string           `json:"symbol"`
	Type             *OrganizationType `json:"type"`
	Website          *string           `json:"website"`
}

// OrganizationType defines model for Organization.Type.
type OrganizationType string

// OrganizationDetail defines model for OrganizationDetail.
type OrganizationDetail struct {
	Email                       string                 `json:"email"`
	IsPrivacyPolicyChecked      *bool                  `json:"is_privacy_policy_checked"`
	IsTermsAndConditionsChecked *bool                  `json:"is_terms_and_conditions_checked"`
	Name                        string                 `json:"name"`
	Phone                       *string                `json:"phone,omitempty"`
	PricingTier                 string                 `json:"pricing_tier"`
	Type                        OrganizationDetailType `json:"type"`
	Website                     *string                `json:"website,omitempty"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// OrganizationDetailType defines model for OrganizationDetail.Type.
type OrganizationDetailType string

// OrganizationId defines model for OrganizationId.
type OrganizationId = string

// PartnerInvitationToken defines model for PartnerInvitationToken.
type PartnerInvitationToken = string

// Query defines model for Query.
type Query = string

// SignupUserPayload defines model for SignupUserPayload.
type SignupUserPayload struct {
	// Language Language for user invitation email
	Language           *SignupUserPayloadLanguage `json:"language,omitempty"`
	OrganizationDetail *OrganizationDetail        `json:"organization_detail,omitempty"`
	UserDetail         *UserDetail                `json:"user_detail,omitempty"`
}

// SignupUserPayloadLanguage Language for user invitation email
type SignupUserPayloadLanguage string

// User defines model for User.
type User struct {
	DisplayName       *string             `json:"display_name,omitempty"`
	Email             openapi_types.Email `json:"email"`
	Id                UserId              `json:"id"`
	ImageUri          *User_ImageUri      `json:"image_uri,omitempty"`
	Name              string              `json:"name"`
	OrganizationId    OrganizationId      `json:"organization_id"`
	PreferredLanguage string              `json:"preferred_language"`
	Properties        []struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"properties"`

	// Roles Deprecated! Please use Permissions API instead
	Roles     []string `json:"roles"`
	Signature *string  `json:"signature,omitempty"`
}

// User_ImageUri defines model for User.ImageUri.
type User_ImageUri struct {
	Original             *string                `json:"original,omitempty"`
	Thumbnail32          *string                `json:"thumbnail_32,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UserActivationPayload defines model for UserActivationPayload.
type UserActivationPayload struct {
	// DisplayName User's display name (default: email address)
	DisplayName *string `json:"display_name,omitempty"`

	// Password User's password
	Password *string `json:"password,omitempty"`
}

// UserDetail defines model for UserDetail.
type UserDetail struct {
	Email    openapi_types.Email `json:"email"`
	FullName string              `json:"full_name"`

	// Password User's password
	Password string `json:"password"`
}

// UserId defines model for UserId.
type UserId = string

// UserInvitationPayload defines model for UserInvitationPayload.
type UserInvitationPayload struct {
	// Email Email address of the address
	Email *string `json:"email,omitempty"`

	// Language Language for user invitation email
	Language *UserInvitationPayloadLanguage `json:"language,omitempty"`
	Roles    *[]string                      `json:"roles,omitempty"`
}

// UserInvitationPayloadLanguage Language for user invitation email
type UserInvitationPayloadLanguage string

// UserV2 defines model for UserV2.
type UserV2 struct {
	CreatedAt *string `json:"created_at,omitempty"`

	// Department User's department
	Department *string `json:"department"`

	// DisplayName User's display name (default: email address)
	DisplayName        *string              `json:"display_name,omitempty"`
	DraftEmail         *openapi_types.Email `json:"draft_email"`
	Email              *openapi_types.Email `json:"email,omitempty"`
	Id                 *UserId              `json:"id,omitempty"`
	ImageUri           *UserV2_ImageUri     `json:"image_uri,omitempty"`
	IsSignatureEnabled *bool                `json:"is_signature_enabled"`
	MfaEnabled         *bool                `json:"mfa_enabled,omitempty"`
	OrganizationId     *OrganizationId      `json:"organization_id,omitempty"`
	Phone              *string              `json:"phone"`
	PhoneVerified      *bool                `json:"phone_verified,omitempty"`
	PreferredLanguage  *string              `json:"preferred_language,omitempty"`
	Properties         *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"properties,omitempty"`
	Signature *string       `json:"signature"`
	Status    *UserV2Status `json:"status,omitempty"`
	Token     *string       `json:"token,omitempty"`
}

// UserV2_ImageUri defines model for UserV2.ImageUri.
type UserV2_ImageUri struct {
	Original             *string                `json:"original,omitempty"`
	Thumbnail32          *string                `json:"thumbnail_32,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UserV2Status defines model for UserV2.Status.
type UserV2Status string

// UserVerificationPayload defines model for UserVerificationPayload.
type UserVerificationPayload struct {
	// Password User's password
	Password *string `json:"password,omitempty"`
}

// Username defines model for Username.
type Username = string

// VerificationToken defines model for VerificationToken.
type VerificationToken = string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// OrgIds Comma-separated list of organization ids to filter by
	OrgIds *[]OrganizationId `form:"org_ids,omitempty" json:"org_ids,omitempty"`

	// Query Query text to filter by
	Query *Query `form:"query,omitempty" json:"query,omitempty"`

	// Limit Limit the results size
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Specify the page
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersV2Params defines parameters for ListUsersV2.
type ListUsersV2Params struct {
	// Query Query text to filter by
	Query *Query `form:"query,omitempty" json:"query,omitempty"`

	// Limit Limit the results size
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Specify the page
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ResendUserInvitationJSONBody defines parameters for ResendUserInvitation.
type ResendUserInvitationJSONBody struct {
	// Email Email address of the address
	Email *string `json:"email,omitempty"`

	// Language Language for user invitation email
	Language *ResendUserInvitationJSONBodyLanguage `json:"language,omitempty"`
}

// ResendUserInvitationJSONBodyLanguage defines parameters for ResendUserInvitation.
type ResendUserInvitationJSONBodyLanguage string

// ActivateUserParams defines parameters for ActivateUser.
type ActivateUserParams struct {
	// Token Invite Token
	Token InviteToken `form:"token" json:"token"`
}

// SignUpUserParams defines parameters for SignUpUser.
type SignUpUserParams struct {
	// Token Invitation partner token
	Token *PartnerInvitationToken `form:"token,omitempty" json:"token,omitempty"`
}

// VerifyEmailWithTokenParams defines parameters for VerifyEmailWithToken.
type VerifyEmailWithTokenParams struct {
	// Token Verification Token
	Token VerificationToken `form:"token" json:"token"`
}

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody = UserInvitationPayload

// ResendUserInvitationJSONRequestBody defines body for ResendUserInvitation for application/json ContentType.
type ResendUserInvitationJSONRequestBody ResendUserInvitationJSONBody

// ActivateUserJSONRequestBody defines body for ActivateUser for application/json ContentType.
type ActivateUserJSONRequestBody = UserActivationPayload

// SignUpUserJSONRequestBody defines body for SignUpUser for application/json ContentType.
type SignUpUserJSONRequestBody = SignupUserPayload

// VerifyEmailWithTokenJSONRequestBody defines body for VerifyEmailWithToken for application/json ContentType.
type VerifyEmailWithTokenJSONRequestBody = UserVerificationPayload

// UpdateUserV2JSONRequestBody defines body for UpdateUserV2 for application/json ContentType.
type UpdateUserV2JSONRequestBody = UserV2

// Getter for additional properties for OrganizationDetail. Returns the specified
// element and whether it was found
func (a OrganizationDetail) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OrganizationDetail
func (a *OrganizationDetail) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OrganizationDetail to handle AdditionalProperties
func (a *OrganizationDetail) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["is_privacy_policy_checked"]; found {
		err = json.Unmarshal(raw, &a.IsPrivacyPolicyChecked)
		if err != nil {
			return fmt.Errorf("error reading 'is_privacy_policy_checked': %w", err)
		}
		delete(object, "is_privacy_policy_checked")
	}

	if raw, found := object["is_terms_and_conditions_checked"]; found {
		err = json.Unmarshal(raw, &a.IsTermsAndConditionsChecked)
		if err != nil {
			return fmt.Errorf("error reading 'is_terms_and_conditions_checked': %w", err)
		}
		delete(object, "is_terms_and_conditions_checked")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["phone"]; found {
		err = json.Unmarshal(raw, &a.Phone)
		if err != nil {
			return fmt.Errorf("error reading 'phone': %w", err)
		}
		delete(object, "phone")
	}

	if raw, found := object["pricing_tier"]; found {
		err = json.Unmarshal(raw, &a.PricingTier)
		if err != nil {
			return fmt.Errorf("error reading 'pricing_tier': %w", err)
		}
		delete(object, "pricing_tier")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["website"]; found {
		err = json.Unmarshal(raw, &a.Website)
		if err != nil {
			return fmt.Errorf("error reading 'website': %w", err)
		}
		delete(object, "website")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OrganizationDetail to handle AdditionalProperties
func (a OrganizationDetail) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["email"], err = json.Marshal(a.Email)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'email': %w", err)
	}

	if a.IsPrivacyPolicyChecked != nil {
		object["is_privacy_policy_checked"], err = json.Marshal(a.IsPrivacyPolicyChecked)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_privacy_policy_checked': %w", err)
		}
	}

	if a.IsTermsAndConditionsChecked != nil {
		object["is_terms_and_conditions_checked"], err = json.Marshal(a.IsTermsAndConditionsChecked)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_terms_and_conditions_checked': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Phone != nil {
		object["phone"], err = json.Marshal(a.Phone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'phone': %w", err)
		}
	}

	object["pricing_tier"], err = json.Marshal(a.PricingTier)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pricing_tier': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Website != nil {
		object["website"], err = json.Marshal(a.Website)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'website': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for User_ImageUri. Returns the specified
// element and whether it was found
func (a User_ImageUri) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for User_ImageUri
func (a *User_ImageUri) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for User_ImageUri to handle AdditionalProperties
func (a *User_ImageUri) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["original"]; found {
		err = json.Unmarshal(raw, &a.Original)
		if err != nil {
			return fmt.Errorf("error reading 'original': %w", err)
		}
		delete(object, "original")
	}

	if raw, found := object["thumbnail_32"]; found {
		err = json.Unmarshal(raw, &a.Thumbnail32)
		if err != nil {
			return fmt.Errorf("error reading 'thumbnail_32': %w", err)
		}
		delete(object, "thumbnail_32")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for User_ImageUri to handle AdditionalProperties
func (a User_ImageUri) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Original != nil {
		object["original"], err = json.Marshal(a.Original)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'original': %w", err)
		}
	}

	if a.Thumbnail32 != nil {
		object["thumbnail_32"], err = json.Marshal(a.Thumbnail32)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'thumbnail_32': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UserV2_ImageUri. Returns the specified
// element and whether it was found
func (a UserV2_ImageUri) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UserV2_ImageUri
func (a *UserV2_ImageUri) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UserV2_ImageUri to handle AdditionalProperties
func (a *UserV2_ImageUri) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["original"]; found {
		err = json.Unmarshal(raw, &a.Original)
		if err != nil {
			return fmt.Errorf("error reading 'original': %w", err)
		}
		delete(object, "original")
	}

	if raw, found := object["thumbnail_32"]; found {
		err = json.Unmarshal(raw, &a.Thumbnail32)
		if err != nil {
			return fmt.Errorf("error reading 'thumbnail_32': %w", err)
		}
		delete(object, "thumbnail_32")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UserV2_ImageUri to handle AdditionalProperties
func (a UserV2_ImageUri) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Original != nil {
		object["original"], err = json.Marshal(a.Original)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'original': %w", err)
		}
	}

	if a.Thumbnail32 != nil {
		object["thumbnail_32"], err = json.Marshal(a.Thumbnail32)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'thumbnail_32': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMe request
	GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserLoginParameters request
	GetUserLoginParameters(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersV2 request
	ListUsersV2(ctx context.Context, params *ListUsersV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUser request with any body
	InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResendUserInvitation request with any body
	ResendUserInvitationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResendUserInvitation(ctx context.Context, body ResendUserInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeV2 request
	GetMeV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateUser request with any body
	ActivateUserWithBody(ctx context.Context, params *ActivateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateUser(ctx context.Context, params *ActivateUserParams, body ActivateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignUpUser request with any body
	SignUpUserWithBody(ctx context.Context, params *SignUpUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignUpUser(ctx context.Context, params *SignUpUserParams, body SignUpUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserLoginParametersV2 request
	GetUserLoginParametersV2(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyEmailWithToken request with any body
	VerifyEmailWithTokenWithBody(ctx context.Context, params *VerifyEmailWithTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyEmailWithToken(ctx context.Context, params *VerifyEmailWithTokenParams, body VerifyEmailWithTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserV2 request
	DeleteUserV2(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserV2 request
	GetUserV2(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserV2 request with any body
	UpdateUserV2WithBody(ctx context.Context, id UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserV2(ctx context.Context, id UserId, body UpdateUserV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserLoginParameters(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserLoginParametersRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersV2(ctx context.Context, params *ListUsersV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendUserInvitationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendUserInvitationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendUserInvitation(ctx context.Context, body ResendUserInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendUserInvitationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserWithBody(ctx context.Context, params *ActivateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUser(ctx context.Context, params *ActivateUserParams, body ActivateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignUpUserWithBody(ctx context.Context, params *SignUpUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignUpUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignUpUser(ctx context.Context, params *SignUpUserParams, body SignUpUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignUpUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserLoginParametersV2(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserLoginParametersV2Request(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmailWithTokenWithBody(ctx context.Context, params *VerifyEmailWithTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailWithTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmailWithToken(ctx context.Context, params *VerifyEmailWithTokenParams, body VerifyEmailWithTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailWithTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserV2(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserV2(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserV2WithBody(ctx context.Context, id UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserV2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserV2(ctx context.Context, id UserId, body UpdateUserV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserV2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrgIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "org_ids", runtime.ParamLocationQuery, *params.OrgIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeRequest generates requests for GetMe
func NewGetMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserLoginParametersRequest generates requests for GetUserLoginParameters
func NewGetUserLoginParametersRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/username/%s:getLoginParameters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersV2Request generates requests for ListUsersV2
func NewListUsersV2Request(server string, params *ListUsersV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResendUserInvitationRequest calls the generic ResendUserInvitation builder with application/json body
func NewResendUserInvitationRequest(server string, body ResendUserInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResendUserInvitationRequestWithBody(server, "application/json", bodyReader)
}

// NewResendUserInvitationRequestWithBody generates requests for ResendUserInvitation with any type of body
func NewResendUserInvitationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/invite:resendEmail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMeV2Request generates requests for GetMeV2
func NewGetMeV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateUserRequest calls the generic ActivateUser builder with application/json body
func NewActivateUserRequest(server string, params *ActivateUserParams, body ActivateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewActivateUserRequestWithBody generates requests for ActivateUser with any type of body
func NewActivateUserRequestWithBody(server string, params *ActivateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/public/activate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSignUpUserRequest calls the generic SignUpUser builder with application/json body
func NewSignUpUserRequest(server string, params *SignUpUserParams, body SignUpUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignUpUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSignUpUserRequestWithBody generates requests for SignUpUser with any type of body
func NewSignUpUserRequestWithBody(server string, params *SignUpUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/public/signup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Token != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserLoginParametersV2Request generates requests for GetUserLoginParametersV2
func NewGetUserLoginParametersV2Request(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/public/username/%s:getLoginParameters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyEmailWithTokenRequest calls the generic VerifyEmailWithToken builder with application/json body
func NewVerifyEmailWithTokenRequest(server string, params *VerifyEmailWithTokenParams, body VerifyEmailWithTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyEmailWithTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewVerifyEmailWithTokenRequestWithBody generates requests for VerifyEmailWithToken with any type of body
func NewVerifyEmailWithTokenRequestWithBody(server string, params *VerifyEmailWithTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/public/verifyEmail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserV2Request generates requests for DeleteUserV2
func NewDeleteUserV2Request(server string, id UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserV2Request generates requests for GetUserV2
func NewGetUserV2Request(server string, id UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserV2Request calls the generic UpdateUserV2 builder with application/json body
func NewUpdateUserV2Request(server string, id UserId, body UpdateUserV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserV2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserV2RequestWithBody generates requests for UpdateUserV2 with any type of body
func NewUpdateUserV2RequestWithBody(server string, id UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// GetMe request
	GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeResponse, error)

	// GetUserLoginParameters request
	GetUserLoginParametersWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserLoginParametersResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListUsersV2 request
	ListUsersV2WithResponse(ctx context.Context, params *ListUsersV2Params, reqEditors ...RequestEditorFn) (*ListUsersV2Response, error)

	// InviteUser request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	// ResendUserInvitation request with any body
	ResendUserInvitationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendUserInvitationResponse, error)

	ResendUserInvitationWithResponse(ctx context.Context, body ResendUserInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendUserInvitationResponse, error)

	// GetMeV2 request
	GetMeV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeV2Response, error)

	// ActivateUser request with any body
	ActivateUserWithBodyWithResponse(ctx context.Context, params *ActivateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserResponse, error)

	ActivateUserWithResponse(ctx context.Context, params *ActivateUserParams, body ActivateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserResponse, error)

	// SignUpUser request with any body
	SignUpUserWithBodyWithResponse(ctx context.Context, params *SignUpUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignUpUserResponse, error)

	SignUpUserWithResponse(ctx context.Context, params *SignUpUserParams, body SignUpUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SignUpUserResponse, error)

	// GetUserLoginParametersV2 request
	GetUserLoginParametersV2WithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserLoginParametersV2Response, error)

	// VerifyEmailWithToken request with any body
	VerifyEmailWithTokenWithBodyWithResponse(ctx context.Context, params *VerifyEmailWithTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailWithTokenResponse, error)

	VerifyEmailWithTokenWithResponse(ctx context.Context, params *VerifyEmailWithTokenParams, body VerifyEmailWithTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailWithTokenResponse, error)

	// DeleteUserV2 request
	DeleteUserV2WithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*DeleteUserV2Response, error)

	// GetUserV2 request
	GetUserV2WithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*GetUserV2Response, error)

	// UpdateUserV2 request with any body
	UpdateUserV2WithBodyWithResponse(ctx context.Context, id UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserV2Response, error)

	UpdateUserV2WithResponse(ctx context.Context, id UserId, body UpdateUserV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserV2Response, error)
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Users *[]User `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserLoginParametersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LoginParameters *[]LoginParameters `json:"login_parameters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserLoginParametersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserLoginParametersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]UserV2 `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsersV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserV2
}

// Status returns HTTPResponse.Status
func (r InviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResendUserInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserV2
}

// Status returns HTTPResponse.Status
func (r ResendUserInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResendUserInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserV2
}

// Status returns HTTPResponse.Status
func (r GetMeV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActivateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignUpUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Organization *Organization `json:"organization,omitempty"`
		User         *User         `json:"user,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SignUpUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignUpUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserLoginParametersV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LoginParameters *[]LoginParameters `json:"login_parameters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserLoginParametersV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserLoginParametersV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyEmailWithTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VerifyEmailWithTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyEmailWithTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r DeleteUserV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserV2
}

// Status returns HTTPResponse.Status
func (r GetUserV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserV2
}

// Status returns HTTPResponse.Status
func (r UpdateUserV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// GetMeWithResponse request returning *GetMeResponse
func (c *ClientWithResponses) GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeResponse, error) {
	rsp, err := c.GetMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeResponse(rsp)
}

// GetUserLoginParametersWithResponse request returning *GetUserLoginParametersResponse
func (c *ClientWithResponses) GetUserLoginParametersWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserLoginParametersResponse, error) {
	rsp, err := c.GetUserLoginParameters(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserLoginParametersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListUsersV2WithResponse request returning *ListUsersV2Response
func (c *ClientWithResponses) ListUsersV2WithResponse(ctx context.Context, params *ListUsersV2Params, reqEditors ...RequestEditorFn) (*ListUsersV2Response, error) {
	rsp, err := c.ListUsersV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersV2Response(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResponse
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

// ResendUserInvitationWithBodyWithResponse request with arbitrary body returning *ResendUserInvitationResponse
func (c *ClientWithResponses) ResendUserInvitationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendUserInvitationResponse, error) {
	rsp, err := c.ResendUserInvitationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendUserInvitationResponse(rsp)
}

func (c *ClientWithResponses) ResendUserInvitationWithResponse(ctx context.Context, body ResendUserInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendUserInvitationResponse, error) {
	rsp, err := c.ResendUserInvitation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendUserInvitationResponse(rsp)
}

// GetMeV2WithResponse request returning *GetMeV2Response
func (c *ClientWithResponses) GetMeV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeV2Response, error) {
	rsp, err := c.GetMeV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeV2Response(rsp)
}

// ActivateUserWithBodyWithResponse request with arbitrary body returning *ActivateUserResponse
func (c *ClientWithResponses) ActivateUserWithBodyWithResponse(ctx context.Context, params *ActivateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserResponse, error) {
	rsp, err := c.ActivateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserResponse(rsp)
}

func (c *ClientWithResponses) ActivateUserWithResponse(ctx context.Context, params *ActivateUserParams, body ActivateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserResponse, error) {
	rsp, err := c.ActivateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserResponse(rsp)
}

// SignUpUserWithBodyWithResponse request with arbitrary body returning *SignUpUserResponse
func (c *ClientWithResponses) SignUpUserWithBodyWithResponse(ctx context.Context, params *SignUpUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignUpUserResponse, error) {
	rsp, err := c.SignUpUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignUpUserResponse(rsp)
}

func (c *ClientWithResponses) SignUpUserWithResponse(ctx context.Context, params *SignUpUserParams, body SignUpUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SignUpUserResponse, error) {
	rsp, err := c.SignUpUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignUpUserResponse(rsp)
}

// GetUserLoginParametersV2WithResponse request returning *GetUserLoginParametersV2Response
func (c *ClientWithResponses) GetUserLoginParametersV2WithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserLoginParametersV2Response, error) {
	rsp, err := c.GetUserLoginParametersV2(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserLoginParametersV2Response(rsp)
}

// VerifyEmailWithTokenWithBodyWithResponse request with arbitrary body returning *VerifyEmailWithTokenResponse
func (c *ClientWithResponses) VerifyEmailWithTokenWithBodyWithResponse(ctx context.Context, params *VerifyEmailWithTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailWithTokenResponse, error) {
	rsp, err := c.VerifyEmailWithTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailWithTokenResponse(rsp)
}

func (c *ClientWithResponses) VerifyEmailWithTokenWithResponse(ctx context.Context, params *VerifyEmailWithTokenParams, body VerifyEmailWithTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailWithTokenResponse, error) {
	rsp, err := c.VerifyEmailWithToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailWithTokenResponse(rsp)
}

// DeleteUserV2WithResponse request returning *DeleteUserV2Response
func (c *ClientWithResponses) DeleteUserV2WithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*DeleteUserV2Response, error) {
	rsp, err := c.DeleteUserV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserV2Response(rsp)
}

// GetUserV2WithResponse request returning *GetUserV2Response
func (c *ClientWithResponses) GetUserV2WithResponse(ctx context.Context, id UserId, reqEditors ...RequestEditorFn) (*GetUserV2Response, error) {
	rsp, err := c.GetUserV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserV2Response(rsp)
}

// UpdateUserV2WithBodyWithResponse request with arbitrary body returning *UpdateUserV2Response
func (c *ClientWithResponses) UpdateUserV2WithBodyWithResponse(ctx context.Context, id UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserV2Response, error) {
	rsp, err := c.UpdateUserV2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserV2Response(rsp)
}

func (c *ClientWithResponses) UpdateUserV2WithResponse(ctx context.Context, id UserId, body UpdateUserV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserV2Response, error) {
	rsp, err := c.UpdateUserV2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserV2Response(rsp)
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Users *[]User `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMeResponse parses an HTTP response from a GetMeWithResponse call
func ParseGetMeResponse(rsp *http.Response) (*GetMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserLoginParametersResponse parses an HTTP response from a GetUserLoginParametersWithResponse call
func ParseGetUserLoginParametersResponse(rsp *http.Response) (*GetUserLoginParametersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserLoginParametersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LoginParameters *[]LoginParameters `json:"login_parameters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersV2Response parses an HTTP response from a ListUsersV2WithResponse call
func ParseListUsersV2Response(rsp *http.Response) (*ListUsersV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]UserV2 `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteUserResponse parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResponse(rsp *http.Response) (*InviteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseResendUserInvitationResponse parses an HTTP response from a ResendUserInvitationWithResponse call
func ParseResendUserInvitationResponse(rsp *http.Response) (*ResendUserInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResendUserInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMeV2Response parses an HTTP response from a GetMeV2WithResponse call
func ParseGetMeV2Response(rsp *http.Response) (*GetMeV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivateUserResponse parses an HTTP response from a ActivateUserWithResponse call
func ParseActivateUserResponse(rsp *http.Response) (*ActivateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSignUpUserResponse parses an HTTP response from a SignUpUserWithResponse call
func ParseSignUpUserResponse(rsp *http.Response) (*SignUpUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignUpUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Organization *Organization `json:"organization,omitempty"`
			User         *User         `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserLoginParametersV2Response parses an HTTP response from a GetUserLoginParametersV2WithResponse call
func ParseGetUserLoginParametersV2Response(rsp *http.Response) (*GetUserLoginParametersV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserLoginParametersV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LoginParameters *[]LoginParameters `json:"login_parameters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVerifyEmailWithTokenResponse parses an HTTP response from a VerifyEmailWithTokenWithResponse call
func ParseVerifyEmailWithTokenResponse(rsp *http.Response) (*VerifyEmailWithTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyEmailWithTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserV2Response parses an HTTP response from a DeleteUserV2WithResponse call
func ParseDeleteUserV2Response(rsp *http.Response) (*DeleteUserV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserV2Response parses an HTTP response from a GetUserV2WithResponse call
func ParseGetUserV2Response(rsp *http.Response) (*GetUserV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserV2Response parses an HTTP response from a UpdateUserV2WithResponse call
func ParseUpdateUserV2Response(rsp *http.Response) (*UpdateUserV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
