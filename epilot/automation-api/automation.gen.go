// Package automation provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package automation_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	EpilotAuthScopes = "EpilotAuth.Scopes"
)

// Defines values for ActivityTriggerConfigurationTypes.
const (
	CreateMeterReading ActivityTriggerConfigurationTypes = "CreateMeterReading"
	MessageActivity    ActivityTriggerConfigurationTypes = "MessageActivity"
	SyncActivity       ActivityTriggerConfigurationTypes = "SyncActivity"
	UpdateMeterReading ActivityTriggerConfigurationTypes = "UpdateMeterReading"
)

// Defines values for ActivityTriggerType.
const (
	Activity ActivityTriggerType = "activity"
)

// Defines values for ApiSubmissionTriggerType.
const (
	ApiSubmission ApiSubmissionTriggerType = "api_submission"
)

// Defines values for Comparison.
const (
	AnyOf    Comparison = "any_of"
	Equals   Comparison = "equals"
	IsEmpty  Comparison = "is_empty"
	NotEmpty Comparison = "not_empty"
)

// Defines values for EntityManualTriggerType.
const (
	EntityManual EntityManualTriggerType = "entity_manual"
)

// Defines values for EntityOperationTriggerConfigurationOperations.
const (
	CreateEntity EntityOperationTriggerConfigurationOperations = "createEntity"
	DeleteEntity EntityOperationTriggerConfigurationOperations = "deleteEntity"
	UpdateEntity EntityOperationTriggerConfigurationOperations = "updateEntity"
)

// Defines values for EntityOperationTriggerType.
const (
	EntityOperation EntityOperationTriggerType = "entity_operation"
)

// Defines values for ErrorCode.
const (
	BADCONFIG             ErrorCode = "BAD_CONFIG"
	DUPLICATEENTITYERROR  ErrorCode = "DUPLICATE_ENTITY_ERROR"
	INTERNALERROR         ErrorCode = "INTERNAL_ERROR"
	MAPPINGERROR          ErrorCode = "MAPPING_ERROR"
	REFRESHRELATIONSERROR ErrorCode = "REFRESH_RELATIONS_ERROR"
	TIMEOUTERROR          ErrorCode = "TIMEOUT_ERROR"
	TRIGGERWORKFLOWERROR  ErrorCode = "TRIGGER_WORKFLOW_ERROR"
)

// Defines values for ExecutionStatus.
const (
	Cancelled  ExecutionStatus = "cancelled"
	Failed     ExecutionStatus = "failed"
	InProgress ExecutionStatus = "in_progress"
	Pending    ExecutionStatus = "pending"
	Success    ExecutionStatus = "success"
)

// Defines values for FrontendSubmitTriggerType.
const (
	FrontendSubmission FrontendSubmitTriggerType = "frontend_submission"
)

// Defines values for JourneySubmitTriggerType.
const (
	JourneySubmission JourneySubmitTriggerType = "journey_submission"
)

// Defines values for MappingAttributeMode.
const (
	AppendIfExists MappingAttributeMode = "append_if_exists"
	CopyIfExists   MappingAttributeMode = "copy_if_exists"
	SetValue       MappingAttributeMode = "set_value"
)

// Defines values for ReceivedEmailTriggerConfigurationMessageType.
const (
	RECEIVED ReceivedEmailTriggerConfigurationMessageType = "RECEIVED"
)

// Defines values for ReceivedEmailTriggerType.
const (
	ReceivedEmail ReceivedEmailTriggerType = "received_email"
)

// Defines values for RelationAttributeMode.
const (
	Append  RelationAttributeMode = "append"
	Prepend RelationAttributeMode = "prepend"
	Set     RelationAttributeMode = "set"
)

// Defines values for RetryStrategy.
const (
	RETRYANDRESUME RetryStrategy = "RETRY_AND_RESUME"
	RETRYANDSTOP   RetryStrategy = "RETRY_AND_STOP"
)

// Defines values for SendEmailConfigAttachmentsSourceFilterDocumentType.
const (
	Application  SendEmailConfigAttachmentsSourceFilterDocumentType = "application"
	Archive      SendEmailConfigAttachmentsSourceFilterDocumentType = "archive"
	Audio        SendEmailConfigAttachmentsSourceFilterDocumentType = "audio"
	Document     SendEmailConfigAttachmentsSourceFilterDocumentType = "document"
	Font         SendEmailConfigAttachmentsSourceFilterDocumentType = "font"
	Image        SendEmailConfigAttachmentsSourceFilterDocumentType = "image"
	Presentation SendEmailConfigAttachmentsSourceFilterDocumentType = "presentation"
	Spreadsheet  SendEmailConfigAttachmentsSourceFilterDocumentType = "spreadsheet"
	Text         SendEmailConfigAttachmentsSourceFilterDocumentType = "text"
	Unknown      SendEmailConfigAttachmentsSourceFilterDocumentType = "unknown"
	Video        SendEmailConfigAttachmentsSourceFilterDocumentType = "video"
)

// Defines values for SendEmailConfigLanguageCode.
const (
	De SendEmailConfigLanguageCode = "de"
	En SendEmailConfigLanguageCode = "en"
)

// ActivityId defines model for ActivityId.
type ActivityId = string

// ActivityTrigger defines model for ActivityTrigger.
type ActivityTrigger struct {
	Configuration struct {
		Schema *string                              `json:"schema,omitempty"`
		Types  *[]ActivityTriggerConfigurationTypes `json:"types,omitempty"`
	} `json:"configuration"`
	Type ActivityTriggerType `json:"type"`
}

// ActivityTriggerConfigurationTypes defines model for ActivityTrigger.Configuration.Types.
type ActivityTriggerConfigurationTypes string

// ActivityTriggerType defines model for ActivityTrigger.Type.
type ActivityTriggerType string

// AnyAction defines model for AnyAction.
type AnyAction struct {
	union json.RawMessage
}

// AnyActionConfig defines model for AnyActionConfig.
type AnyActionConfig struct {
	union json.RawMessage
}

// AnyTrigger defines model for AnyTrigger.
type AnyTrigger struct {
	union json.RawMessage
}

// ApiSubmissionTrigger defines model for ApiSubmissionTrigger.
type ApiSubmissionTrigger struct {
	Configuration struct {
		SourceId *string `json:"source_id,omitempty"`
	} `json:"configuration"`
	Type ApiSubmissionTriggerType `json:"type"`
}

// ApiSubmissionTriggerType defines model for ApiSubmissionTrigger.Type.
type ApiSubmissionTriggerType string

// AppendValueMapper defines model for AppendValueMapper.
type AppendValueMapper struct {
	// Mode - copy_if_exists - it replaces the target attribute with the source value - append_if_exists - it currently replaces target attribute with array like values. Useful when you have multiple values to be added into one attribute. - set_value - it sets a value to a predefined value. Must be used together with value property.
	Mode MappingAttributeMode `json:"mode"`

	// Source JSON source path for the value to be extracted from the main entity. Eg: steps[1].['Product Info'].price
	Source *string `json:"source,omitempty"`

	// Target JSON like target path for the attribute. Eg. last_name
	Target string `json:"target"`

	// TargetUnique Array of keys which should be used when checking for uniqueness. Eg: [country, city, postal_code]
	TargetUnique *[]string `json:"target_unique,omitempty"`

	// ValueJson To be provided only when mapping json objects into a target attribute. Eg array of addresses.
	ValueJson string `json:"value_json"`
}

// AssignUsersToStep defines model for AssignUsersToStep.
type AssignUsersToStep struct {
	StepId   *string    `json:"step_id,omitempty"`
	StepName *string    `json:"step_name,omitempty"`
	UserIds  *[]float32 `json:"user_ids,omitempty"`
}

// AutomationAction defines model for AutomationAction.
type AutomationAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                   `json:"allow_failure,omitempty"`
	Config       *map[string]interface{} `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *string        `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// AutomationActionConfig defines model for AutomationActionConfig.
type AutomationActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                   `json:"allow_failure,omitempty"`
	Config       *map[string]interface{} `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *string             `json:"type,omitempty"`
}

// AutomationActionExecutionState defines model for AutomationActionExecutionState.
type AutomationActionExecutionState struct {
	ErrorOutput     *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus *ExecutionStatus        `json:"execution_status,omitempty"`
	Outputs         *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// AutomationActionId defines model for AutomationActionId.
type AutomationActionId = string

// AutomationExecution defines model for AutomationExecution.
type AutomationExecution struct {
	Actions         []AnyAction           `json:"actions"`
	ActivityId      *ActivityId           `json:"activity_id,omitempty"`
	CreatedAt       *time.Time            `json:"created_at,omitempty"`
	CurrentActionId *AutomationActionId   `json:"current_action_id,omitempty"`
	EntityId        EntityId              `json:"entity_id"`
	EntitySnapshot  *EntityItemSnapshot   `json:"entity_snapshot,omitempty"`
	ExecutionStatus *ExecutionStatus      `json:"execution_status,omitempty"`
	FlowId          AutomationFlowId      `json:"flow_id"`
	FlowName        *string               `json:"flow_name,omitempty"`
	Id              AutomationExecutionId `json:"id"`
	OrgId           OrganizationId        `json:"org_id"`
	UpdatedAt       *time.Time            `json:"updated_at,omitempty"`
}

// AutomationExecutionId defines model for AutomationExecutionId.
type AutomationExecutionId = string

// AutomationFlow defines model for AutomationFlow.
type AutomationFlow struct {
	Actions   []AnyActionConfig `json:"actions"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// CreatedBy User / service who created automation flow
	CreatedBy *string `json:"created_by,omitempty"`

	// Enabled Whether the automation is enabled or not
	Enabled *bool `json:"enabled,omitempty"`

	// EntitySchema The triggering entity schema
	EntitySchema *string `json:"entity_schema,omitempty"`

	// FlowName A descriptive name for the Automation
	FlowName string            `json:"flow_name"`
	Id       *AutomationFlowId `json:"id,omitempty"`

	// LastUpdatedBy User / service who last updated automation flow
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// Runs Number of automation executions that ran
	Runs              *float32            `json:"runs,omitempty"`
	TriggerConditions *[]TriggerCondition `json:"trigger_conditions,omitempty"`
	Triggers          []AnyTrigger        `json:"triggers"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
}

// AutomationFlowId defines model for AutomationFlowId.
type AutomationFlowId = string

// CartCheckoutAction defines model for CartCheckoutAction.
type CartCheckoutAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool               `json:"allow_failure,omitempty"`
	Config       *CartCheckoutConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// CartCheckoutActionConfig defines model for CartCheckoutActionConfig.
type CartCheckoutActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool               `json:"allow_failure,omitempty"`
	Config       *CartCheckoutConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// CartCheckoutConfig defines model for CartCheckoutConfig.
type CartCheckoutConfig struct {
	// LinkbackRelationAttribute Relation attribute on the main entity where the target entity will be linked. Set to false to disable linkback
	LinkbackRelationAttribute *string `json:"linkback_relation_attribute,omitempty"`

	// LinkbackRelationTags Relation tags (labels) to include in main entity linkback relation attribute
	LinkbackRelationTags *[]string                                    `json:"linkback_relation_tags,omitempty"`
	MappingAttributes    *[]CartCheckoutConfig_MappingAttributes_Item `json:"mapping_attributes,omitempty"`
	MappingConfig        *MappingConfigRef                            `json:"mapping_config,omitempty"`
	RelationAttributes   *[]RelationAttribute                         `json:"relation_attributes,omitempty"`

	// TargetUnique Unique key for target entity (see upsertEntity of Entity API)
	TargetUnique *[]string `json:"target_unique,omitempty"`

	// Version Version of the config
	Version *string `json:"version,omitempty"`
}

// CartCheckoutConfig_MappingAttributes_Item defines model for CartCheckoutConfig.mapping_attributes.Item.
type CartCheckoutConfig_MappingAttributes_Item struct {
	union json.RawMessage
}

// Comparison defines model for Comparison.
type Comparison string

// CopyValueMapper defines model for CopyValueMapper.
type CopyValueMapper struct {
	// Mode - copy_if_exists - it replaces the target attribute with the source value - append_if_exists - it currently replaces target attribute with array like values. Useful when you have multiple values to be added into one attribute. - set_value - it sets a value to a predefined value. Must be used together with value property.
	Mode MappingAttributeMode `json:"mode"`

	// Source JSON source path for the value to be extracted from the main entity. Eg: steps[1].['Product Info'].price
	Source string `json:"source"`

	// Target JSON like target path for the attribute. Eg. last_name
	Target string `json:"target"`
}

// CreateDocumentAction defines model for CreateDocumentAction.
type CreateDocumentAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                 `json:"allow_failure,omitempty"`
	Config       *CreateDocumentConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// CreateDocumentActionConfig defines model for CreateDocumentActionConfig.
type CreateDocumentActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                 `json:"allow_failure,omitempty"`
	Config       *CreateDocumentConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// CreateDocumentConfig defines model for CreateDocumentConfig.
type CreateDocumentConfig struct {
	Filename   *string `json:"filename,omitempty"`
	TemplateId *string `json:"template_id,omitempty"`
}

// EntityId defines model for EntityId.
type EntityId = string

// EntityItemSnapshot defines model for EntityItemSnapshot.
type EntityItemSnapshot struct {
	CreatedAt            time.Time              `json:"_created_at"`
	Id                   EntityId               `json:"_id"`
	Org                  string                 `json:"_org"`
	Schema               string                 `json:"_schema"`
	Tags                 *[]string              `json:"_tags,omitempty"`
	Title                string                 `json:"_title"`
	UpdatedAt            time.Time              `json:"_updated_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// EntityManualTrigger defines model for EntityManualTrigger.
type EntityManualTrigger struct {
	Configuration struct {
		// Schema Which entity type can this automation be triggered from
		Schema *string `json:"schema,omitempty"`
	} `json:"configuration"`
	Type EntityManualTriggerType `json:"type"`
}

// EntityManualTriggerType defines model for EntityManualTrigger.Type.
type EntityManualTriggerType string

// EntityOperationTrigger defines model for EntityOperationTrigger.
type EntityOperationTrigger struct {
	Configuration struct {
		ExcludeActivities *[]string                                       `json:"exclude_activities,omitempty"`
		IncludeActivities *[]string                                       `json:"include_activities,omitempty"`
		Operations        []EntityOperationTriggerConfigurationOperations `json:"operations"`
		Schema            string                                          `json:"schema"`
	} `json:"configuration"`
	Type EntityOperationTriggerType `json:"type"`
}

// EntityOperationTriggerConfigurationOperations defines model for EntityOperationTrigger.Configuration.Operations.
type EntityOperationTriggerConfigurationOperations string

// EntityOperationTriggerType defines model for EntityOperationTrigger.Type.
type EntityOperationTriggerType string

// ErrorCode defines model for ErrorCode.
type ErrorCode string

// ErrorOutput defines model for ErrorOutput.
type ErrorOutput struct {
	ErrorCode   ErrorCode `json:"error_code"`
	ErrorReason string    `json:"error_reason"`
}

// ExecutionStatus defines model for ExecutionStatus.
type ExecutionStatus string

// FrontendSubmitTrigger defines model for FrontendSubmitTrigger.
type FrontendSubmitTrigger struct {
	Configuration struct {
		SourceId *string `json:"source_id,omitempty"`
	} `json:"configuration"`
	Type FrontendSubmitTriggerType `json:"type"`
}

// FrontendSubmitTriggerType defines model for FrontendSubmitTrigger.Type.
type FrontendSubmitTriggerType string

// GetExecutionsResp defines model for GetExecutionsResp.
type GetExecutionsResp struct {
	Results []AutomationExecution `json:"results"`
	Total   float32               `json:"total"`
}

// JourneySubmitTrigger defines model for JourneySubmitTrigger.
type JourneySubmitTrigger struct {
	Configuration struct {
		SourceId openapi_types.UUID `json:"source_id"`
	} `json:"configuration"`
	Type JourneySubmitTriggerType `json:"type"`
}

// JourneySubmitTriggerType defines model for JourneySubmitTrigger.Type.
type JourneySubmitTriggerType string

// MapEntityAction defines model for MapEntityAction.
type MapEntityAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool            `json:"allow_failure,omitempty"`
	Config       *MapEntityConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// MapEntityActionConfig defines model for MapEntityActionConfig.
type MapEntityActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool            `json:"allow_failure,omitempty"`
	Config       *MapEntityConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// MapEntityConfig defines model for MapEntityConfig.
type MapEntityConfig struct {
	// LinkbackRelationAttribute Relation attribute on the main entity where the target entity will be linked. Set to false to disable linkback
	LinkbackRelationAttribute *string `json:"linkback_relation_attribute,omitempty"`

	// LinkbackRelationTags Relation tags (labels) to include in main entity linkback relation attribute
	LinkbackRelationTags *[]string `json:"linkback_relation_tags,omitempty"`

	// MappingAttributes Attribute mappings
	MappingAttributes *[]MapEntityConfig_MappingAttributes_Item `json:"mapping_attributes,omitempty"`
	MappingConfig     *MappingConfigRef                         `json:"mapping_config,omitempty"`

	// RelationAttributes Relation mappings
	RelationAttributes *[]RelationAttribute `json:"relation_attributes,omitempty"`

	// TargetSchema Schema of target entity
	TargetSchema string `json:"target_schema"`

	// TargetUnique Unique key for target entity (see upsertEntity of Entity API)
	TargetUnique *[]string `json:"target_unique,omitempty"`
}

// MapEntityConfig_MappingAttributes_Item defines model for MapEntityConfig.mapping_attributes.Item.
type MapEntityConfig_MappingAttributes_Item struct {
	union json.RawMessage
}

// MappingAttribute defines model for MappingAttribute.
type MappingAttribute struct {
	union json.RawMessage
}

// MappingAttributeMode - copy_if_exists - it replaces the target attribute with the source value - append_if_exists - it currently replaces target attribute with array like values. Useful when you have multiple values to be added into one attribute. - set_value - it sets a value to a predefined value. Must be used together with value property.
type MappingAttributeMode string

// MappingAttributeV2 defines model for MappingAttributeV2.
type MappingAttributeV2 struct {
	// Operation Mapping operation nodes are either primitive values or operation node objects
	Operation OperationNode `json:"operation"`

	// Target Target JSON path for the attribute to set
	Target *string `json:"target,omitempty"`
}

// MappingConfigRef defines model for MappingConfigRef.
type MappingConfigRef struct {
	// ConfigId Id of Entity Mapping Configuration to run for mapping.
	ConfigId string `json:"config_id"`

	// TargetId Id of TargetConfig to run for mapping.
	TargetId string `json:"target_id"`

	// Version Version of Entity Mapping Configuration to run for mapping.
	Version *float32 `json:"version,omitempty"`
}

// OperationNode Mapping operation nodes are either primitive values or operation node objects
type OperationNode struct {
	union json.RawMessage
}

// OperationObjectNode defines model for OperationObjectNode.
type OperationObjectNode struct {
	// Append Append to array
	Append *interface{} `json:"_append,omitempty"`

	// Copy Copy JSONPath value from source entity context
	Copy *string `json:"_copy,omitempty"`

	// Set Represents any primitive JSON value
	_Set *PrimitiveJSONValue `json:"_set,omitempty"`

	// Uniq Unique array
	Uniq                 *OperationObjectNode_Uniq `json:"_uniq,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// OperationObjectNodeUniq0 defines model for .
type OperationObjectNodeUniq0 = bool

// OperationObjectNodeUniq1 Unique key consisting of object keys
type OperationObjectNodeUniq1 = []string

// OperationObjectNode_Uniq Unique array
type OperationObjectNode_Uniq struct {
	union json.RawMessage
}

// OrganizationId defines model for OrganizationId.
type OrganizationId = string

// PrimitiveJSONValue Represents any primitive JSON value
type PrimitiveJSONValue struct {
	union json.RawMessage
}

// PrimitiveJSONValue0 defines model for .
type PrimitiveJSONValue0 = string

// PrimitiveJSONValue1 defines model for .
type PrimitiveJSONValue1 = bool

// PrimitiveJSONValue2 defines model for .
type PrimitiveJSONValue2 = float32

// PrimitiveJSONValue3 defines model for .
type PrimitiveJSONValue3 map[string]interface{}

// PrimitiveJSONValue4 defines model for .
type PrimitiveJSONValue4 = []interface{}

// ReceivedEmailTrigger defines model for ReceivedEmailTrigger.
type ReceivedEmailTrigger struct {
	Configuration struct {
		MessageType *ReceivedEmailTriggerConfigurationMessageType `json:"message_type,omitempty"`
	} `json:"configuration"`
	Type ReceivedEmailTriggerType `json:"type"`
}

// ReceivedEmailTriggerConfigurationMessageType defines model for ReceivedEmailTrigger.Configuration.MessageType.
type ReceivedEmailTriggerConfigurationMessageType string

// ReceivedEmailTriggerType defines model for ReceivedEmailTrigger.Type.
type ReceivedEmailTriggerType string

// RelationAttribute defines model for RelationAttribute.
type RelationAttribute struct {
	Mode      RelationAttributeMode   `json:"mode"`
	RelatedTo *map[string]interface{} `json:"related_to,omitempty"`

	// SourceFilter A filter to identify which source entities to pick as relations from main entity
	SourceFilter *struct {
		// Attribute Filter by a specific relation attribute on the main entity
		Attribute *string `json:"attribute,omitempty"`

		// Limit Limit relations to maximum number (default, all matched relations)
		Limit *int `json:"limit,omitempty"`

		// RelationTag Filter by relation tag (label) on the main entity
		RelationTag *string `json:"relation_tag,omitempty"`

		// Schema Filter by specific schema
		Schema *string `json:"schema,omitempty"`

		// Self Picks main entity as relation (overrides other filters)
		Self *bool `json:"self,omitempty"`

		// Tag Filter by a specific tag on the related entity
		Tag *string `json:"tag,omitempty"`
	} `json:"source_filter,omitempty"`

	// Target Target attribute to store the relation in
	Target string `json:"target"`

	// TargetTags Relation tags (labels) to set for the stored relations
	TargetTags *[]string `json:"target_tags,omitempty"`

	// TargetTagsIncludeSource Include all relation tags (labels) present on the main entity relation
	TargetTagsIncludeSource *bool `json:"target_tags_include_source,omitempty"`
}

// RelationAttributeMode defines model for RelationAttribute.Mode.
type RelationAttributeMode string

// RetryReq defines model for RetryReq.
type RetryReq struct {
	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
}

// RetryStrategy different behaviors for retrying failed execution actions.
type RetryStrategy string

// SearchAutomationsResp defines model for SearchAutomationsResp.
type SearchAutomationsResp struct {
	Results []AutomationFlow `json:"results"`
	Total   float32          `json:"total"`
}

// SendEmailAction defines model for SendEmailAction.
type SendEmailAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool            `json:"allow_failure,omitempty"`
	Config       *SendEmailConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// SendEmailActionConfig defines model for SendEmailActionConfig.
type SendEmailActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool            `json:"allow_failure,omitempty"`
	Config       *SendEmailConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// SendEmailConfig defines model for SendEmailConfig.
type SendEmailConfig struct {
	// Attachments Include extra file attachments in sent email.
	//
	// Attachments in email template will be sent regardless of this configuration.
	Attachments *[]struct {
		// SourceFilter Specify filters to match file entities related to main entity
		SourceFilter *struct {
			// Attribute Filter by a specific relation attribute on the main entity
			Attribute *string `json:"attribute,omitempty"`

			// DocumentType Filter by a specific document type (e.g. document)
			DocumentType *SendEmailConfigAttachmentsSourceFilterDocumentType `json:"document_type,omitempty"`

			// FilenameRegex Match by filename. Regex syntax supported
			FilenameRegex *string `json:"filename_regex,omitempty"`

			// Limit Limit files to maximum number (default, all matched file relations)
			Limit *int `json:"limit,omitempty"`

			// RelationTag Filter by relation tag (label) on the main entity
			RelationTag *string `json:"relation_tag,omitempty"`

			// Self Picks main entity as file (only works if source entity is a file)
			Self *bool `json:"self,omitempty"`

			// Tag Filter by a specific tag on the related file entity
			Tag *string `json:"tag,omitempty"`
		} `json:"source_filter,omitempty"`
	} `json:"attachments,omitempty"`
	EmailTemplateId *string                      `json:"email_template_id,omitempty"`
	LanguageCode    *SendEmailConfigLanguageCode `json:"language_code,omitempty"`
}

// SendEmailConfigAttachmentsSourceFilterDocumentType Filter by a specific document type (e.g. document)
type SendEmailConfigAttachmentsSourceFilterDocumentType string

// SendEmailConfigLanguageCode defines model for SendEmailConfig.LanguageCode.
type SendEmailConfigLanguageCode string

// SetValueMapper defines model for SetValueMapper.
type SetValueMapper struct {
	// Mode - copy_if_exists - it replaces the target attribute with the source value - append_if_exists - it currently replaces target attribute with array like values. Useful when you have multiple values to be added into one attribute. - set_value - it sets a value to a predefined value. Must be used together with value property.
	Mode MappingAttributeMode `json:"mode"`

	// Target JSON like target path for the attribute. Eg. last_name
	Target string `json:"target"`

	// Value Any value to be set: string, number, string[], number[], JSON object, etc. It will override existing values, if any.
	Value interface{} `json:"value"`
}

// StartExecutionRequest defines model for StartExecutionRequest.
type StartExecutionRequest struct {
	EntityId *EntityId         `json:"entity_id,omitempty"`
	FlowId   *AutomationFlowId `json:"flow_id,omitempty"`
}

// TriggerCondition defines model for TriggerCondition.
type TriggerCondition struct {
	Comparison Comparison              `json:"comparison"`
	Source     string                  `json:"source"`
	Value      *TriggerCondition_Value `json:"value,omitempty"`
}

// TriggerConditionValue0 defines model for .
type TriggerConditionValue0 = string

// TriggerConditionValue1 defines model for .
type TriggerConditionValue1 = float32

// TriggerConditionValue2 defines model for .
type TriggerConditionValue2 = []string

// TriggerConditionValue3 defines model for .
type TriggerConditionValue3 = []float32

// TriggerCondition_Value defines model for TriggerCondition.Value.
type TriggerCondition_Value struct {
	union json.RawMessage
}

// TriggerWebhookAction defines model for TriggerWebhookAction.
type TriggerWebhookAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                 `json:"allow_failure,omitempty"`
	Config       *TriggerWebhookConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// TriggerWebhookActionConfig defines model for TriggerWebhookActionConfig.
type TriggerWebhookActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                 `json:"allow_failure,omitempty"`
	Config       *TriggerWebhookConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// TriggerWebhookConfig defines model for TriggerWebhookConfig.
type TriggerWebhookConfig struct {
	EntitySources   *[]string `json:"entity_sources,omitempty"`
	TargetWebhookId *string   `json:"target_webhook_id,omitempty"`
}

// TriggerWorkflowAction defines model for TriggerWorkflowAction.
type TriggerWorkflowAction struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                  `json:"allow_failure,omitempty"`
	Config       *TriggerWorkflowConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool                   `json:"created_automatically,omitempty"`
	ErrorOutput          *ErrorOutput            `json:"error_output,omitempty"`
	ExecutionStatus      *ExecutionStatus        `json:"execution_status,omitempty"`
	FlowActionId         *AutomationActionId     `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId     `json:"id,omitempty"`
	Name                 *string                 `json:"name,omitempty"`
	Outputs              *map[string]interface{} `json:"outputs,omitempty"`

	// RetryStrategy different behaviors for retrying failed execution actions.
	RetryStrategy *RetryStrategy `json:"retry_strategy,omitempty"`
	StartedAt     *string        `json:"started_at,omitempty"`
	Type          *interface{}   `json:"type,omitempty"`
	UpdatedAt     *string        `json:"updated_at,omitempty"`
}

// TriggerWorkflowActionConfig defines model for TriggerWorkflowActionConfig.
type TriggerWorkflowActionConfig struct {
	// AllowFailure Whether to stop execution in a failed state if this action fails
	AllowFailure *bool                  `json:"allow_failure,omitempty"`
	Config       *TriggerWorkflowConfig `json:"config,omitempty"`

	// CreatedAutomatically Flag indicating whether the action was created automatically or manually
	CreatedAutomatically *bool               `json:"created_automatically,omitempty"`
	FlowActionId         *AutomationActionId `json:"flow_action_id,omitempty"`
	Id                   *AutomationActionId `json:"id,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Type                 *interface{}        `json:"type,omitempty"`
}

// TriggerWorkflowCondition defines model for TriggerWorkflowCondition.
type TriggerWorkflowCondition struct {
	Comparison Comparison                      `json:"comparison"`
	Schema     *string                         `json:"schema,omitempty"`
	Source     string                          `json:"source"`
	Value      *TriggerWorkflowCondition_Value `json:"value,omitempty"`
}

// TriggerWorkflowConditionValue0 defines model for .
type TriggerWorkflowConditionValue0 = string

// TriggerWorkflowConditionValue1 defines model for .
type TriggerWorkflowConditionValue1 = float32

// TriggerWorkflowConditionValue2 defines model for .
type TriggerWorkflowConditionValue2 = []string

// TriggerWorkflowConditionValue3 defines model for .
type TriggerWorkflowConditionValue3 = []float32

// TriggerWorkflowCondition_Value defines model for TriggerWorkflowCondition.Value.
type TriggerWorkflowCondition_Value struct {
	union json.RawMessage
}

// TriggerWorkflowConfig defines model for TriggerWorkflowConfig.
type TriggerWorkflowConfig struct {
	AssignSteps    *[]AssignUsersToStep        `json:"assign_steps,omitempty"`
	Assignees      *[]string                   `json:"assignees,omitempty"`
	Conditions     *[]TriggerWorkflowCondition `json:"conditions,omitempty"`
	TargetWorkflow *string                     `json:"target_workflow,omitempty"`
}

// GetExecutionsParams defines parameters for GetExecutions.
type GetExecutionsParams struct {
	EntityId *EntityId `form:"entity_id,omitempty" json:"entity_id,omitempty"`

	// Size Pagination: max number of results to return
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// From Pagination: starting for results
	From *int `form:"from,omitempty" json:"from,omitempty"`
}

// SearchFlowsParams defines parameters for SearchFlows.
type SearchFlowsParams struct {
	// Schema Entity Schema
	Schema *string `form:"schema,omitempty" json:"schema,omitempty"`

	// Size Pagination: max number of results to return
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// From Pagination: starting for results
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// TriggerSourceId Trigger source identifier
	TriggerSourceId *string `form:"trigger_source_id,omitempty" json:"trigger_source_id,omitempty"`
}

// StartExecutionJSONRequestBody defines body for StartExecution for application/json ContentType.
type StartExecutionJSONRequestBody = StartExecutionRequest

// RetriggerActionJSONRequestBody defines body for RetriggerAction for application/json ContentType.
type RetriggerActionJSONRequestBody = RetryReq

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody = AutomationFlow

// PutFlowJSONRequestBody defines body for PutFlow for application/json ContentType.
type PutFlowJSONRequestBody = AutomationFlow

// Getter for additional properties for EntityItemSnapshot. Returns the specified
// element and whether it was found
func (a EntityItemSnapshot) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EntityItemSnapshot
func (a *EntityItemSnapshot) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EntityItemSnapshot to handle AdditionalProperties
func (a *EntityItemSnapshot) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["_created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading '_created_at': %w", err)
		}
		delete(object, "_created_at")
	}

	if raw, found := object["_id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading '_id': %w", err)
		}
		delete(object, "_id")
	}

	if raw, found := object["_org"]; found {
		err = json.Unmarshal(raw, &a.Org)
		if err != nil {
			return fmt.Errorf("error reading '_org': %w", err)
		}
		delete(object, "_org")
	}

	if raw, found := object["_schema"]; found {
		err = json.Unmarshal(raw, &a.Schema)
		if err != nil {
			return fmt.Errorf("error reading '_schema': %w", err)
		}
		delete(object, "_schema")
	}

	if raw, found := object["_tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading '_tags': %w", err)
		}
		delete(object, "_tags")
	}

	if raw, found := object["_title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading '_title': %w", err)
		}
		delete(object, "_title")
	}

	if raw, found := object["_updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading '_updated_at': %w", err)
		}
		delete(object, "_updated_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EntityItemSnapshot to handle AdditionalProperties
func (a EntityItemSnapshot) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["_created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_created_at': %w", err)
	}

	object["_id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_id': %w", err)
	}

	object["_org"], err = json.Marshal(a.Org)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_org': %w", err)
	}

	object["_schema"], err = json.Marshal(a.Schema)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_schema': %w", err)
	}

	if a.Tags != nil {
		object["_tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '_tags': %w", err)
		}
	}

	object["_title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_title': %w", err)
	}

	object["_updated_at"], err = json.Marshal(a.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '_updated_at': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OperationObjectNode. Returns the specified
// element and whether it was found
func (a OperationObjectNode) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OperationObjectNode
func (a *OperationObjectNode) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OperationObjectNode to handle AdditionalProperties
func (a *OperationObjectNode) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["_append"]; found {
		err = json.Unmarshal(raw, &a.Append)
		if err != nil {
			return fmt.Errorf("error reading '_append': %w", err)
		}
		delete(object, "_append")
	}

	if raw, found := object["_copy"]; found {
		err = json.Unmarshal(raw, &a.Copy)
		if err != nil {
			return fmt.Errorf("error reading '_copy': %w", err)
		}
		delete(object, "_copy")
	}

	if raw, found := object["_set"]; found {
		err = json.Unmarshal(raw, &a._Set)
		if err != nil {
			return fmt.Errorf("error reading '_set': %w", err)
		}
		delete(object, "_set")
	}

	if raw, found := object["_uniq"]; found {
		err = json.Unmarshal(raw, &a.Uniq)
		if err != nil {
			return fmt.Errorf("error reading '_uniq': %w", err)
		}
		delete(object, "_uniq")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OperationObjectNode to handle AdditionalProperties
func (a OperationObjectNode) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Append != nil {
		object["_append"], err = json.Marshal(a.Append)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '_append': %w", err)
		}
	}

	if a.Copy != nil {
		object["_copy"], err = json.Marshal(a.Copy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '_copy': %w", err)
		}
	}

	if a._Set != nil {
		object["_set"], err = json.Marshal(a._Set)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '_set': %w", err)
		}
	}

	if a.Uniq != nil {
		object["_uniq"], err = json.Marshal(a.Uniq)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '_uniq': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsMapEntityAction returns the union data inside the AnyAction as a MapEntityAction
func (t AnyAction) AsMapEntityAction() (MapEntityAction, error) {
	var body MapEntityAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapEntityAction overwrites any union data inside the AnyAction as the provided MapEntityAction
func (t *AnyAction) FromMapEntityAction(v MapEntityAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapEntityAction performs a merge with any union data inside the AnyAction, using the provided MapEntityAction
func (t *AnyAction) MergeMapEntityAction(v MapEntityAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWorkflowAction returns the union data inside the AnyAction as a TriggerWorkflowAction
func (t AnyAction) AsTriggerWorkflowAction() (TriggerWorkflowAction, error) {
	var body TriggerWorkflowAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowAction overwrites any union data inside the AnyAction as the provided TriggerWorkflowAction
func (t *AnyAction) FromTriggerWorkflowAction(v TriggerWorkflowAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowAction performs a merge with any union data inside the AnyAction, using the provided TriggerWorkflowAction
func (t *AnyAction) MergeTriggerWorkflowAction(v TriggerWorkflowAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWebhookAction returns the union data inside the AnyAction as a TriggerWebhookAction
func (t AnyAction) AsTriggerWebhookAction() (TriggerWebhookAction, error) {
	var body TriggerWebhookAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWebhookAction overwrites any union data inside the AnyAction as the provided TriggerWebhookAction
func (t *AnyAction) FromTriggerWebhookAction(v TriggerWebhookAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWebhookAction performs a merge with any union data inside the AnyAction, using the provided TriggerWebhookAction
func (t *AnyAction) MergeTriggerWebhookAction(v TriggerWebhookAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateDocumentAction returns the union data inside the AnyAction as a CreateDocumentAction
func (t AnyAction) AsCreateDocumentAction() (CreateDocumentAction, error) {
	var body CreateDocumentAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateDocumentAction overwrites any union data inside the AnyAction as the provided CreateDocumentAction
func (t *AnyAction) FromCreateDocumentAction(v CreateDocumentAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateDocumentAction performs a merge with any union data inside the AnyAction, using the provided CreateDocumentAction
func (t *AnyAction) MergeCreateDocumentAction(v CreateDocumentAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSendEmailAction returns the union data inside the AnyAction as a SendEmailAction
func (t AnyAction) AsSendEmailAction() (SendEmailAction, error) {
	var body SendEmailAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendEmailAction overwrites any union data inside the AnyAction as the provided SendEmailAction
func (t *AnyAction) FromSendEmailAction(v SendEmailAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendEmailAction performs a merge with any union data inside the AnyAction, using the provided SendEmailAction
func (t *AnyAction) MergeSendEmailAction(v SendEmailAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCartCheckoutAction returns the union data inside the AnyAction as a CartCheckoutAction
func (t AnyAction) AsCartCheckoutAction() (CartCheckoutAction, error) {
	var body CartCheckoutAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCartCheckoutAction overwrites any union data inside the AnyAction as the provided CartCheckoutAction
func (t *AnyAction) FromCartCheckoutAction(v CartCheckoutAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCartCheckoutAction performs a merge with any union data inside the AnyAction, using the provided CartCheckoutAction
func (t *AnyAction) MergeCartCheckoutAction(v CartCheckoutAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAutomationAction returns the union data inside the AnyAction as a AutomationAction
func (t AnyAction) AsAutomationAction() (AutomationAction, error) {
	var body AutomationAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutomationAction overwrites any union data inside the AnyAction as the provided AutomationAction
func (t *AnyAction) FromAutomationAction(v AutomationAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutomationAction performs a merge with any union data inside the AnyAction, using the provided AutomationAction
func (t *AnyAction) MergeAutomationAction(v AutomationAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AnyAction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnyAction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMapEntityActionConfig returns the union data inside the AnyActionConfig as a MapEntityActionConfig
func (t AnyActionConfig) AsMapEntityActionConfig() (MapEntityActionConfig, error) {
	var body MapEntityActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapEntityActionConfig overwrites any union data inside the AnyActionConfig as the provided MapEntityActionConfig
func (t *AnyActionConfig) FromMapEntityActionConfig(v MapEntityActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapEntityActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided MapEntityActionConfig
func (t *AnyActionConfig) MergeMapEntityActionConfig(v MapEntityActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWorkflowActionConfig returns the union data inside the AnyActionConfig as a TriggerWorkflowActionConfig
func (t AnyActionConfig) AsTriggerWorkflowActionConfig() (TriggerWorkflowActionConfig, error) {
	var body TriggerWorkflowActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowActionConfig overwrites any union data inside the AnyActionConfig as the provided TriggerWorkflowActionConfig
func (t *AnyActionConfig) FromTriggerWorkflowActionConfig(v TriggerWorkflowActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided TriggerWorkflowActionConfig
func (t *AnyActionConfig) MergeTriggerWorkflowActionConfig(v TriggerWorkflowActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWebhookActionConfig returns the union data inside the AnyActionConfig as a TriggerWebhookActionConfig
func (t AnyActionConfig) AsTriggerWebhookActionConfig() (TriggerWebhookActionConfig, error) {
	var body TriggerWebhookActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWebhookActionConfig overwrites any union data inside the AnyActionConfig as the provided TriggerWebhookActionConfig
func (t *AnyActionConfig) FromTriggerWebhookActionConfig(v TriggerWebhookActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWebhookActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided TriggerWebhookActionConfig
func (t *AnyActionConfig) MergeTriggerWebhookActionConfig(v TriggerWebhookActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateDocumentActionConfig returns the union data inside the AnyActionConfig as a CreateDocumentActionConfig
func (t AnyActionConfig) AsCreateDocumentActionConfig() (CreateDocumentActionConfig, error) {
	var body CreateDocumentActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateDocumentActionConfig overwrites any union data inside the AnyActionConfig as the provided CreateDocumentActionConfig
func (t *AnyActionConfig) FromCreateDocumentActionConfig(v CreateDocumentActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateDocumentActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided CreateDocumentActionConfig
func (t *AnyActionConfig) MergeCreateDocumentActionConfig(v CreateDocumentActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSendEmailActionConfig returns the union data inside the AnyActionConfig as a SendEmailActionConfig
func (t AnyActionConfig) AsSendEmailActionConfig() (SendEmailActionConfig, error) {
	var body SendEmailActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendEmailActionConfig overwrites any union data inside the AnyActionConfig as the provided SendEmailActionConfig
func (t *AnyActionConfig) FromSendEmailActionConfig(v SendEmailActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendEmailActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided SendEmailActionConfig
func (t *AnyActionConfig) MergeSendEmailActionConfig(v SendEmailActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCartCheckoutActionConfig returns the union data inside the AnyActionConfig as a CartCheckoutActionConfig
func (t AnyActionConfig) AsCartCheckoutActionConfig() (CartCheckoutActionConfig, error) {
	var body CartCheckoutActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCartCheckoutActionConfig overwrites any union data inside the AnyActionConfig as the provided CartCheckoutActionConfig
func (t *AnyActionConfig) FromCartCheckoutActionConfig(v CartCheckoutActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCartCheckoutActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided CartCheckoutActionConfig
func (t *AnyActionConfig) MergeCartCheckoutActionConfig(v CartCheckoutActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAutomationActionConfig returns the union data inside the AnyActionConfig as a AutomationActionConfig
func (t AnyActionConfig) AsAutomationActionConfig() (AutomationActionConfig, error) {
	var body AutomationActionConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutomationActionConfig overwrites any union data inside the AnyActionConfig as the provided AutomationActionConfig
func (t *AnyActionConfig) FromAutomationActionConfig(v AutomationActionConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutomationActionConfig performs a merge with any union data inside the AnyActionConfig, using the provided AutomationActionConfig
func (t *AnyActionConfig) MergeAutomationActionConfig(v AutomationActionConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AnyActionConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnyActionConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFrontendSubmitTrigger returns the union data inside the AnyTrigger as a FrontendSubmitTrigger
func (t AnyTrigger) AsFrontendSubmitTrigger() (FrontendSubmitTrigger, error) {
	var body FrontendSubmitTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFrontendSubmitTrigger overwrites any union data inside the AnyTrigger as the provided FrontendSubmitTrigger
func (t *AnyTrigger) FromFrontendSubmitTrigger(v FrontendSubmitTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFrontendSubmitTrigger performs a merge with any union data inside the AnyTrigger, using the provided FrontendSubmitTrigger
func (t *AnyTrigger) MergeFrontendSubmitTrigger(v FrontendSubmitTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJourneySubmitTrigger returns the union data inside the AnyTrigger as a JourneySubmitTrigger
func (t AnyTrigger) AsJourneySubmitTrigger() (JourneySubmitTrigger, error) {
	var body JourneySubmitTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJourneySubmitTrigger overwrites any union data inside the AnyTrigger as the provided JourneySubmitTrigger
func (t *AnyTrigger) FromJourneySubmitTrigger(v JourneySubmitTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJourneySubmitTrigger performs a merge with any union data inside the AnyTrigger, using the provided JourneySubmitTrigger
func (t *AnyTrigger) MergeJourneySubmitTrigger(v JourneySubmitTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsApiSubmissionTrigger returns the union data inside the AnyTrigger as a ApiSubmissionTrigger
func (t AnyTrigger) AsApiSubmissionTrigger() (ApiSubmissionTrigger, error) {
	var body ApiSubmissionTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiSubmissionTrigger overwrites any union data inside the AnyTrigger as the provided ApiSubmissionTrigger
func (t *AnyTrigger) FromApiSubmissionTrigger(v ApiSubmissionTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiSubmissionTrigger performs a merge with any union data inside the AnyTrigger, using the provided ApiSubmissionTrigger
func (t *AnyTrigger) MergeApiSubmissionTrigger(v ApiSubmissionTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEntityOperationTrigger returns the union data inside the AnyTrigger as a EntityOperationTrigger
func (t AnyTrigger) AsEntityOperationTrigger() (EntityOperationTrigger, error) {
	var body EntityOperationTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntityOperationTrigger overwrites any union data inside the AnyTrigger as the provided EntityOperationTrigger
func (t *AnyTrigger) FromEntityOperationTrigger(v EntityOperationTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntityOperationTrigger performs a merge with any union data inside the AnyTrigger, using the provided EntityOperationTrigger
func (t *AnyTrigger) MergeEntityOperationTrigger(v EntityOperationTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsActivityTrigger returns the union data inside the AnyTrigger as a ActivityTrigger
func (t AnyTrigger) AsActivityTrigger() (ActivityTrigger, error) {
	var body ActivityTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActivityTrigger overwrites any union data inside the AnyTrigger as the provided ActivityTrigger
func (t *AnyTrigger) FromActivityTrigger(v ActivityTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActivityTrigger performs a merge with any union data inside the AnyTrigger, using the provided ActivityTrigger
func (t *AnyTrigger) MergeActivityTrigger(v ActivityTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEntityManualTrigger returns the union data inside the AnyTrigger as a EntityManualTrigger
func (t AnyTrigger) AsEntityManualTrigger() (EntityManualTrigger, error) {
	var body EntityManualTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntityManualTrigger overwrites any union data inside the AnyTrigger as the provided EntityManualTrigger
func (t *AnyTrigger) FromEntityManualTrigger(v EntityManualTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntityManualTrigger performs a merge with any union data inside the AnyTrigger, using the provided EntityManualTrigger
func (t *AnyTrigger) MergeEntityManualTrigger(v EntityManualTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceivedEmailTrigger returns the union data inside the AnyTrigger as a ReceivedEmailTrigger
func (t AnyTrigger) AsReceivedEmailTrigger() (ReceivedEmailTrigger, error) {
	var body ReceivedEmailTrigger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceivedEmailTrigger overwrites any union data inside the AnyTrigger as the provided ReceivedEmailTrigger
func (t *AnyTrigger) FromReceivedEmailTrigger(v ReceivedEmailTrigger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceivedEmailTrigger performs a merge with any union data inside the AnyTrigger, using the provided ReceivedEmailTrigger
func (t *AnyTrigger) MergeReceivedEmailTrigger(v ReceivedEmailTrigger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AnyTrigger) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnyTrigger) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMappingAttributeV2 returns the union data inside the CartCheckoutConfig_MappingAttributes_Item as a MappingAttributeV2
func (t CartCheckoutConfig_MappingAttributes_Item) AsMappingAttributeV2() (MappingAttributeV2, error) {
	var body MappingAttributeV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMappingAttributeV2 overwrites any union data inside the CartCheckoutConfig_MappingAttributes_Item as the provided MappingAttributeV2
func (t *CartCheckoutConfig_MappingAttributes_Item) FromMappingAttributeV2(v MappingAttributeV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMappingAttributeV2 performs a merge with any union data inside the CartCheckoutConfig_MappingAttributes_Item, using the provided MappingAttributeV2
func (t *CartCheckoutConfig_MappingAttributes_Item) MergeMappingAttributeV2(v MappingAttributeV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMappingAttribute returns the union data inside the CartCheckoutConfig_MappingAttributes_Item as a MappingAttribute
func (t CartCheckoutConfig_MappingAttributes_Item) AsMappingAttribute() (MappingAttribute, error) {
	var body MappingAttribute
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMappingAttribute overwrites any union data inside the CartCheckoutConfig_MappingAttributes_Item as the provided MappingAttribute
func (t *CartCheckoutConfig_MappingAttributes_Item) FromMappingAttribute(v MappingAttribute) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMappingAttribute performs a merge with any union data inside the CartCheckoutConfig_MappingAttributes_Item, using the provided MappingAttribute
func (t *CartCheckoutConfig_MappingAttributes_Item) MergeMappingAttribute(v MappingAttribute) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CartCheckoutConfig_MappingAttributes_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CartCheckoutConfig_MappingAttributes_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMappingAttributeV2 returns the union data inside the MapEntityConfig_MappingAttributes_Item as a MappingAttributeV2
func (t MapEntityConfig_MappingAttributes_Item) AsMappingAttributeV2() (MappingAttributeV2, error) {
	var body MappingAttributeV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMappingAttributeV2 overwrites any union data inside the MapEntityConfig_MappingAttributes_Item as the provided MappingAttributeV2
func (t *MapEntityConfig_MappingAttributes_Item) FromMappingAttributeV2(v MappingAttributeV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMappingAttributeV2 performs a merge with any union data inside the MapEntityConfig_MappingAttributes_Item, using the provided MappingAttributeV2
func (t *MapEntityConfig_MappingAttributes_Item) MergeMappingAttributeV2(v MappingAttributeV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMappingAttribute returns the union data inside the MapEntityConfig_MappingAttributes_Item as a MappingAttribute
func (t MapEntityConfig_MappingAttributes_Item) AsMappingAttribute() (MappingAttribute, error) {
	var body MappingAttribute
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMappingAttribute overwrites any union data inside the MapEntityConfig_MappingAttributes_Item as the provided MappingAttribute
func (t *MapEntityConfig_MappingAttributes_Item) FromMappingAttribute(v MappingAttribute) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMappingAttribute performs a merge with any union data inside the MapEntityConfig_MappingAttributes_Item, using the provided MappingAttribute
func (t *MapEntityConfig_MappingAttributes_Item) MergeMappingAttribute(v MappingAttribute) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t MapEntityConfig_MappingAttributes_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MapEntityConfig_MappingAttributes_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSetValueMapper returns the union data inside the MappingAttribute as a SetValueMapper
func (t MappingAttribute) AsSetValueMapper() (SetValueMapper, error) {
	var body SetValueMapper
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetValueMapper overwrites any union data inside the MappingAttribute as the provided SetValueMapper
func (t *MappingAttribute) FromSetValueMapper(v SetValueMapper) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetValueMapper performs a merge with any union data inside the MappingAttribute, using the provided SetValueMapper
func (t *MappingAttribute) MergeSetValueMapper(v SetValueMapper) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCopyValueMapper returns the union data inside the MappingAttribute as a CopyValueMapper
func (t MappingAttribute) AsCopyValueMapper() (CopyValueMapper, error) {
	var body CopyValueMapper
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCopyValueMapper overwrites any union data inside the MappingAttribute as the provided CopyValueMapper
func (t *MappingAttribute) FromCopyValueMapper(v CopyValueMapper) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCopyValueMapper performs a merge with any union data inside the MappingAttribute, using the provided CopyValueMapper
func (t *MappingAttribute) MergeCopyValueMapper(v CopyValueMapper) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAppendValueMapper returns the union data inside the MappingAttribute as a AppendValueMapper
func (t MappingAttribute) AsAppendValueMapper() (AppendValueMapper, error) {
	var body AppendValueMapper
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppendValueMapper overwrites any union data inside the MappingAttribute as the provided AppendValueMapper
func (t *MappingAttribute) FromAppendValueMapper(v AppendValueMapper) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppendValueMapper performs a merge with any union data inside the MappingAttribute, using the provided AppendValueMapper
func (t *MappingAttribute) MergeAppendValueMapper(v AppendValueMapper) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t MappingAttribute) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MappingAttribute) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationObjectNode returns the union data inside the OperationNode as a OperationObjectNode
func (t OperationNode) AsOperationObjectNode() (OperationObjectNode, error) {
	var body OperationObjectNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationObjectNode overwrites any union data inside the OperationNode as the provided OperationObjectNode
func (t *OperationNode) FromOperationObjectNode(v OperationObjectNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationObjectNode performs a merge with any union data inside the OperationNode, using the provided OperationObjectNode
func (t *OperationNode) MergeOperationObjectNode(v OperationObjectNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPrimitiveJSONValue returns the union data inside the OperationNode as a PrimitiveJSONValue
func (t OperationNode) AsPrimitiveJSONValue() (PrimitiveJSONValue, error) {
	var body PrimitiveJSONValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue overwrites any union data inside the OperationNode as the provided PrimitiveJSONValue
func (t *OperationNode) FromPrimitiveJSONValue(v PrimitiveJSONValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue performs a merge with any union data inside the OperationNode, using the provided PrimitiveJSONValue
func (t *OperationNode) MergePrimitiveJSONValue(v PrimitiveJSONValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OperationNode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OperationNode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationObjectNodeUniq0 returns the union data inside the OperationObjectNode_Uniq as a OperationObjectNodeUniq0
func (t OperationObjectNode_Uniq) AsOperationObjectNodeUniq0() (OperationObjectNodeUniq0, error) {
	var body OperationObjectNodeUniq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationObjectNodeUniq0 overwrites any union data inside the OperationObjectNode_Uniq as the provided OperationObjectNodeUniq0
func (t *OperationObjectNode_Uniq) FromOperationObjectNodeUniq0(v OperationObjectNodeUniq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationObjectNodeUniq0 performs a merge with any union data inside the OperationObjectNode_Uniq, using the provided OperationObjectNodeUniq0
func (t *OperationObjectNode_Uniq) MergeOperationObjectNodeUniq0(v OperationObjectNodeUniq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOperationObjectNodeUniq1 returns the union data inside the OperationObjectNode_Uniq as a OperationObjectNodeUniq1
func (t OperationObjectNode_Uniq) AsOperationObjectNodeUniq1() (OperationObjectNodeUniq1, error) {
	var body OperationObjectNodeUniq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationObjectNodeUniq1 overwrites any union data inside the OperationObjectNode_Uniq as the provided OperationObjectNodeUniq1
func (t *OperationObjectNode_Uniq) FromOperationObjectNodeUniq1(v OperationObjectNodeUniq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationObjectNodeUniq1 performs a merge with any union data inside the OperationObjectNode_Uniq, using the provided OperationObjectNodeUniq1
func (t *OperationObjectNode_Uniq) MergeOperationObjectNodeUniq1(v OperationObjectNodeUniq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OperationObjectNode_Uniq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OperationObjectNode_Uniq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrimitiveJSONValue0 returns the union data inside the PrimitiveJSONValue as a PrimitiveJSONValue0
func (t PrimitiveJSONValue) AsPrimitiveJSONValue0() (PrimitiveJSONValue0, error) {
	var body PrimitiveJSONValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue0 overwrites any union data inside the PrimitiveJSONValue as the provided PrimitiveJSONValue0
func (t *PrimitiveJSONValue) FromPrimitiveJSONValue0(v PrimitiveJSONValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue0 performs a merge with any union data inside the PrimitiveJSONValue, using the provided PrimitiveJSONValue0
func (t *PrimitiveJSONValue) MergePrimitiveJSONValue0(v PrimitiveJSONValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPrimitiveJSONValue1 returns the union data inside the PrimitiveJSONValue as a PrimitiveJSONValue1
func (t PrimitiveJSONValue) AsPrimitiveJSONValue1() (PrimitiveJSONValue1, error) {
	var body PrimitiveJSONValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue1 overwrites any union data inside the PrimitiveJSONValue as the provided PrimitiveJSONValue1
func (t *PrimitiveJSONValue) FromPrimitiveJSONValue1(v PrimitiveJSONValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue1 performs a merge with any union data inside the PrimitiveJSONValue, using the provided PrimitiveJSONValue1
func (t *PrimitiveJSONValue) MergePrimitiveJSONValue1(v PrimitiveJSONValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPrimitiveJSONValue2 returns the union data inside the PrimitiveJSONValue as a PrimitiveJSONValue2
func (t PrimitiveJSONValue) AsPrimitiveJSONValue2() (PrimitiveJSONValue2, error) {
	var body PrimitiveJSONValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue2 overwrites any union data inside the PrimitiveJSONValue as the provided PrimitiveJSONValue2
func (t *PrimitiveJSONValue) FromPrimitiveJSONValue2(v PrimitiveJSONValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue2 performs a merge with any union data inside the PrimitiveJSONValue, using the provided PrimitiveJSONValue2
func (t *PrimitiveJSONValue) MergePrimitiveJSONValue2(v PrimitiveJSONValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPrimitiveJSONValue3 returns the union data inside the PrimitiveJSONValue as a PrimitiveJSONValue3
func (t PrimitiveJSONValue) AsPrimitiveJSONValue3() (PrimitiveJSONValue3, error) {
	var body PrimitiveJSONValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue3 overwrites any union data inside the PrimitiveJSONValue as the provided PrimitiveJSONValue3
func (t *PrimitiveJSONValue) FromPrimitiveJSONValue3(v PrimitiveJSONValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue3 performs a merge with any union data inside the PrimitiveJSONValue, using the provided PrimitiveJSONValue3
func (t *PrimitiveJSONValue) MergePrimitiveJSONValue3(v PrimitiveJSONValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPrimitiveJSONValue4 returns the union data inside the PrimitiveJSONValue as a PrimitiveJSONValue4
func (t PrimitiveJSONValue) AsPrimitiveJSONValue4() (PrimitiveJSONValue4, error) {
	var body PrimitiveJSONValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveJSONValue4 overwrites any union data inside the PrimitiveJSONValue as the provided PrimitiveJSONValue4
func (t *PrimitiveJSONValue) FromPrimitiveJSONValue4(v PrimitiveJSONValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveJSONValue4 performs a merge with any union data inside the PrimitiveJSONValue, using the provided PrimitiveJSONValue4
func (t *PrimitiveJSONValue) MergePrimitiveJSONValue4(v PrimitiveJSONValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PrimitiveJSONValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrimitiveJSONValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTriggerConditionValue0 returns the union data inside the TriggerCondition_Value as a TriggerConditionValue0
func (t TriggerCondition_Value) AsTriggerConditionValue0() (TriggerConditionValue0, error) {
	var body TriggerConditionValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerConditionValue0 overwrites any union data inside the TriggerCondition_Value as the provided TriggerConditionValue0
func (t *TriggerCondition_Value) FromTriggerConditionValue0(v TriggerConditionValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerConditionValue0 performs a merge with any union data inside the TriggerCondition_Value, using the provided TriggerConditionValue0
func (t *TriggerCondition_Value) MergeTriggerConditionValue0(v TriggerConditionValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerConditionValue1 returns the union data inside the TriggerCondition_Value as a TriggerConditionValue1
func (t TriggerCondition_Value) AsTriggerConditionValue1() (TriggerConditionValue1, error) {
	var body TriggerConditionValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerConditionValue1 overwrites any union data inside the TriggerCondition_Value as the provided TriggerConditionValue1
func (t *TriggerCondition_Value) FromTriggerConditionValue1(v TriggerConditionValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerConditionValue1 performs a merge with any union data inside the TriggerCondition_Value, using the provided TriggerConditionValue1
func (t *TriggerCondition_Value) MergeTriggerConditionValue1(v TriggerConditionValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerConditionValue2 returns the union data inside the TriggerCondition_Value as a TriggerConditionValue2
func (t TriggerCondition_Value) AsTriggerConditionValue2() (TriggerConditionValue2, error) {
	var body TriggerConditionValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerConditionValue2 overwrites any union data inside the TriggerCondition_Value as the provided TriggerConditionValue2
func (t *TriggerCondition_Value) FromTriggerConditionValue2(v TriggerConditionValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerConditionValue2 performs a merge with any union data inside the TriggerCondition_Value, using the provided TriggerConditionValue2
func (t *TriggerCondition_Value) MergeTriggerConditionValue2(v TriggerConditionValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerConditionValue3 returns the union data inside the TriggerCondition_Value as a TriggerConditionValue3
func (t TriggerCondition_Value) AsTriggerConditionValue3() (TriggerConditionValue3, error) {
	var body TriggerConditionValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerConditionValue3 overwrites any union data inside the TriggerCondition_Value as the provided TriggerConditionValue3
func (t *TriggerCondition_Value) FromTriggerConditionValue3(v TriggerConditionValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerConditionValue3 performs a merge with any union data inside the TriggerCondition_Value, using the provided TriggerConditionValue3
func (t *TriggerCondition_Value) MergeTriggerConditionValue3(v TriggerConditionValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TriggerCondition_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TriggerCondition_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTriggerWorkflowConditionValue0 returns the union data inside the TriggerWorkflowCondition_Value as a TriggerWorkflowConditionValue0
func (t TriggerWorkflowCondition_Value) AsTriggerWorkflowConditionValue0() (TriggerWorkflowConditionValue0, error) {
	var body TriggerWorkflowConditionValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowConditionValue0 overwrites any union data inside the TriggerWorkflowCondition_Value as the provided TriggerWorkflowConditionValue0
func (t *TriggerWorkflowCondition_Value) FromTriggerWorkflowConditionValue0(v TriggerWorkflowConditionValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowConditionValue0 performs a merge with any union data inside the TriggerWorkflowCondition_Value, using the provided TriggerWorkflowConditionValue0
func (t *TriggerWorkflowCondition_Value) MergeTriggerWorkflowConditionValue0(v TriggerWorkflowConditionValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWorkflowConditionValue1 returns the union data inside the TriggerWorkflowCondition_Value as a TriggerWorkflowConditionValue1
func (t TriggerWorkflowCondition_Value) AsTriggerWorkflowConditionValue1() (TriggerWorkflowConditionValue1, error) {
	var body TriggerWorkflowConditionValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowConditionValue1 overwrites any union data inside the TriggerWorkflowCondition_Value as the provided TriggerWorkflowConditionValue1
func (t *TriggerWorkflowCondition_Value) FromTriggerWorkflowConditionValue1(v TriggerWorkflowConditionValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowConditionValue1 performs a merge with any union data inside the TriggerWorkflowCondition_Value, using the provided TriggerWorkflowConditionValue1
func (t *TriggerWorkflowCondition_Value) MergeTriggerWorkflowConditionValue1(v TriggerWorkflowConditionValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWorkflowConditionValue2 returns the union data inside the TriggerWorkflowCondition_Value as a TriggerWorkflowConditionValue2
func (t TriggerWorkflowCondition_Value) AsTriggerWorkflowConditionValue2() (TriggerWorkflowConditionValue2, error) {
	var body TriggerWorkflowConditionValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowConditionValue2 overwrites any union data inside the TriggerWorkflowCondition_Value as the provided TriggerWorkflowConditionValue2
func (t *TriggerWorkflowCondition_Value) FromTriggerWorkflowConditionValue2(v TriggerWorkflowConditionValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowConditionValue2 performs a merge with any union data inside the TriggerWorkflowCondition_Value, using the provided TriggerWorkflowConditionValue2
func (t *TriggerWorkflowCondition_Value) MergeTriggerWorkflowConditionValue2(v TriggerWorkflowConditionValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTriggerWorkflowConditionValue3 returns the union data inside the TriggerWorkflowCondition_Value as a TriggerWorkflowConditionValue3
func (t TriggerWorkflowCondition_Value) AsTriggerWorkflowConditionValue3() (TriggerWorkflowConditionValue3, error) {
	var body TriggerWorkflowConditionValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTriggerWorkflowConditionValue3 overwrites any union data inside the TriggerWorkflowCondition_Value as the provided TriggerWorkflowConditionValue3
func (t *TriggerWorkflowCondition_Value) FromTriggerWorkflowConditionValue3(v TriggerWorkflowConditionValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTriggerWorkflowConditionValue3 performs a merge with any union data inside the TriggerWorkflowCondition_Value, using the provided TriggerWorkflowConditionValue3
func (t *TriggerWorkflowCondition_Value) MergeTriggerWorkflowConditionValue3(v TriggerWorkflowConditionValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TriggerWorkflowCondition_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TriggerWorkflowCondition_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetExecutions request
	GetExecutions(ctx context.Context, params *GetExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartExecution request with any body
	StartExecutionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartExecution(ctx context.Context, body StartExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelExecution request
	CancelExecution(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExecution request
	GetExecution(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetriggerAction request with any body
	RetriggerActionWithBody(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RetriggerAction(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, body RetriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFlows request
	SearchFlows(ctx context.Context, params *SearchFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlow request with any body
	CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlow(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlow request
	DeleteFlow(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlow request
	GetFlow(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFlow request with any body
	PutFlowWithBody(ctx context.Context, flowId AutomationFlowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFlow(ctx context.Context, flowId AutomationFlowId, body PutFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetExecutions(ctx context.Context, params *GetExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartExecutionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartExecutionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartExecution(ctx context.Context, body StartExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartExecutionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelExecution(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelExecutionRequest(c.Server, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExecution(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutionRequest(c.Server, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetriggerActionWithBody(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetriggerActionRequestWithBody(c.Server, executionId, actionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetriggerAction(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, body RetriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetriggerActionRequest(c.Server, executionId, actionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFlows(ctx context.Context, params *SearchFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFlowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlow(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlow(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowRequest(c.Server, flowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlow(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowRequest(c.Server, flowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFlowWithBody(ctx context.Context, flowId AutomationFlowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFlowRequestWithBody(c.Server, flowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFlow(ctx context.Context, flowId AutomationFlowId, body PutFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFlowRequest(c.Server, flowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetExecutionsRequest generates requests for GetExecutions
func NewGetExecutionsRequest(server string, params *GetExecutionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/executions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EntityId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entity_id", runtime.ParamLocationQuery, *params.EntityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartExecutionRequest calls the generic StartExecution builder with application/json body
func NewStartExecutionRequest(server string, body StartExecutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartExecutionRequestWithBody(server, "application/json", bodyReader)
}

// NewStartExecutionRequestWithBody generates requests for StartExecution with any type of body
func NewStartExecutionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/executions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelExecutionRequest generates requests for CancelExecution
func NewCancelExecutionRequest(server string, executionId AutomationExecutionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/executions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExecutionRequest generates requests for GetExecution
func NewGetExecutionRequest(server string, executionId AutomationExecutionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/executions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetriggerActionRequest calls the generic RetriggerAction builder with application/json body
func NewRetriggerActionRequest(server string, executionId AutomationExecutionId, actionId AutomationActionId, body RetriggerActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRetriggerActionRequestWithBody(server, executionId, actionId, "application/json", bodyReader)
}

// NewRetriggerActionRequestWithBody generates requests for RetriggerAction with any type of body
func NewRetriggerActionRequestWithBody(server string, executionId AutomationExecutionId, actionId AutomationActionId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/executions/%s/%s/retrigger", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchFlowsRequest generates requests for SearchFlows
func NewSearchFlowsRequest(server string, params *SearchFlowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Schema != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema", runtime.ParamLocationQuery, *params.Schema); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TriggerSourceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trigger_source_id", runtime.ParamLocationQuery, *params.TriggerSourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlowRequest calls the generic CreateFlow builder with application/json body
func NewCreateFlowRequest(server string, body CreateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func NewCreateFlowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowRequest generates requests for DeleteFlow
func NewDeleteFlowRequest(server string, flowId AutomationFlowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flow_id", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowRequest generates requests for GetFlow
func NewGetFlowRequest(server string, flowId AutomationFlowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flow_id", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFlowRequest calls the generic PutFlow builder with application/json body
func NewPutFlowRequest(server string, flowId AutomationFlowId, body PutFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFlowRequestWithBody(server, flowId, "application/json", bodyReader)
}

// NewPutFlowRequestWithBody generates requests for PutFlow with any type of body
func NewPutFlowRequestWithBody(server string, flowId AutomationFlowId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flow_id", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/automation/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetExecutions request
	GetExecutionsWithResponse(ctx context.Context, params *GetExecutionsParams, reqEditors ...RequestEditorFn) (*GetExecutionsResponse, error)

	// StartExecution request with any body
	StartExecutionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartExecutionResponse, error)

	StartExecutionWithResponse(ctx context.Context, body StartExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*StartExecutionResponse, error)

	// CancelExecution request
	CancelExecutionWithResponse(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*CancelExecutionResponse, error)

	// GetExecution request
	GetExecutionWithResponse(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*GetExecutionResponse, error)

	// RetriggerAction request with any body
	RetriggerActionWithBodyWithResponse(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetriggerActionResponse, error)

	RetriggerActionWithResponse(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, body RetriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*RetriggerActionResponse, error)

	// SearchFlows request
	SearchFlowsWithResponse(ctx context.Context, params *SearchFlowsParams, reqEditors ...RequestEditorFn) (*SearchFlowsResponse, error)

	// CreateFlow request with any body
	CreateFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	CreateFlowWithResponse(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	// DeleteFlow request
	DeleteFlowWithResponse(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*DeleteFlowResponse, error)

	// GetFlow request
	GetFlowWithResponse(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*GetFlowResponse, error)

	// PutFlow request with any body
	PutFlowWithBodyWithResponse(ctx context.Context, flowId AutomationFlowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFlowResponse, error)

	PutFlowWithResponse(ctx context.Context, flowId AutomationFlowId, body PutFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFlowResponse, error)
}

type GetExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExecutionsResp
}

// Status returns HTTPResponse.Status
func (r GetExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutomationExecution
}

// Status returns HTTPResponse.Status
func (r StartExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationExecution
}

// Status returns HTTPResponse.Status
func (r CancelExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationExecution
}

// Status returns HTTPResponse.Status
func (r GetExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetriggerActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RetriggerActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetriggerActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchAutomationsResp
}

// Status returns HTTPResponse.Status
func (r SearchFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutomationFlow
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationFlow
}

// Status returns HTTPResponse.Status
func (r DeleteFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationFlow
}

// Status returns HTTPResponse.Status
func (r GetFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationFlow
}

// Status returns HTTPResponse.Status
func (r PutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetExecutionsWithResponse request returning *GetExecutionsResponse
func (c *ClientWithResponses) GetExecutionsWithResponse(ctx context.Context, params *GetExecutionsParams, reqEditors ...RequestEditorFn) (*GetExecutionsResponse, error) {
	rsp, err := c.GetExecutions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutionsResponse(rsp)
}

// StartExecutionWithBodyWithResponse request with arbitrary body returning *StartExecutionResponse
func (c *ClientWithResponses) StartExecutionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartExecutionResponse, error) {
	rsp, err := c.StartExecutionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartExecutionResponse(rsp)
}

func (c *ClientWithResponses) StartExecutionWithResponse(ctx context.Context, body StartExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*StartExecutionResponse, error) {
	rsp, err := c.StartExecution(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartExecutionResponse(rsp)
}

// CancelExecutionWithResponse request returning *CancelExecutionResponse
func (c *ClientWithResponses) CancelExecutionWithResponse(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*CancelExecutionResponse, error) {
	rsp, err := c.CancelExecution(ctx, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelExecutionResponse(rsp)
}

// GetExecutionWithResponse request returning *GetExecutionResponse
func (c *ClientWithResponses) GetExecutionWithResponse(ctx context.Context, executionId AutomationExecutionId, reqEditors ...RequestEditorFn) (*GetExecutionResponse, error) {
	rsp, err := c.GetExecution(ctx, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutionResponse(rsp)
}

// RetriggerActionWithBodyWithResponse request with arbitrary body returning *RetriggerActionResponse
func (c *ClientWithResponses) RetriggerActionWithBodyWithResponse(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetriggerActionResponse, error) {
	rsp, err := c.RetriggerActionWithBody(ctx, executionId, actionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetriggerActionResponse(rsp)
}

func (c *ClientWithResponses) RetriggerActionWithResponse(ctx context.Context, executionId AutomationExecutionId, actionId AutomationActionId, body RetriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*RetriggerActionResponse, error) {
	rsp, err := c.RetriggerAction(ctx, executionId, actionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetriggerActionResponse(rsp)
}

// SearchFlowsWithResponse request returning *SearchFlowsResponse
func (c *ClientWithResponses) SearchFlowsWithResponse(ctx context.Context, params *SearchFlowsParams, reqEditors ...RequestEditorFn) (*SearchFlowsResponse, error) {
	rsp, err := c.SearchFlows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFlowsResponse(rsp)
}

// CreateFlowWithBodyWithResponse request with arbitrary body returning *CreateFlowResponse
func (c *ClientWithResponses) CreateFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateFlowWithResponse(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

// DeleteFlowWithResponse request returning *DeleteFlowResponse
func (c *ClientWithResponses) DeleteFlowWithResponse(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*DeleteFlowResponse, error) {
	rsp, err := c.DeleteFlow(ctx, flowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowResponse(rsp)
}

// GetFlowWithResponse request returning *GetFlowResponse
func (c *ClientWithResponses) GetFlowWithResponse(ctx context.Context, flowId AutomationFlowId, reqEditors ...RequestEditorFn) (*GetFlowResponse, error) {
	rsp, err := c.GetFlow(ctx, flowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowResponse(rsp)
}

// PutFlowWithBodyWithResponse request with arbitrary body returning *PutFlowResponse
func (c *ClientWithResponses) PutFlowWithBodyWithResponse(ctx context.Context, flowId AutomationFlowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFlowResponse, error) {
	rsp, err := c.PutFlowWithBody(ctx, flowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFlowResponse(rsp)
}

func (c *ClientWithResponses) PutFlowWithResponse(ctx context.Context, flowId AutomationFlowId, body PutFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFlowResponse, error) {
	rsp, err := c.PutFlow(ctx, flowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFlowResponse(rsp)
}

// ParseGetExecutionsResponse parses an HTTP response from a GetExecutionsWithResponse call
func ParseGetExecutionsResponse(rsp *http.Response) (*GetExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExecutionsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartExecutionResponse parses an HTTP response from a StartExecutionWithResponse call
func ParseStartExecutionResponse(rsp *http.Response) (*StartExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutomationExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCancelExecutionResponse parses an HTTP response from a CancelExecutionWithResponse call
func ParseCancelExecutionResponse(rsp *http.Response) (*CancelExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExecutionResponse parses an HTTP response from a GetExecutionWithResponse call
func ParseGetExecutionResponse(rsp *http.Response) (*GetExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetriggerActionResponse parses an HTTP response from a RetriggerActionWithResponse call
func ParseRetriggerActionResponse(rsp *http.Response) (*RetriggerActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetriggerActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchFlowsResponse parses an HTTP response from a SearchFlowsWithResponse call
func ParseSearchFlowsResponse(rsp *http.Response) (*SearchFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchAutomationsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFlowResponse parses an HTTP response from a CreateFlowWithResponse call
func ParseCreateFlowResponse(rsp *http.Response) (*CreateFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutomationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteFlowResponse parses an HTTP response from a DeleteFlowWithResponse call
func ParseDeleteFlowResponse(rsp *http.Response) (*DeleteFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowResponse parses an HTTP response from a GetFlowWithResponse call
func ParseGetFlowResponse(rsp *http.Response) (*GetFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutFlowResponse parses an HTTP response from a PutFlowWithResponse call
func ParsePutFlowResponse(rsp *http.Response) (*PutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
